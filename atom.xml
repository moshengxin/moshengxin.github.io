<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mosey</title>
  <icon>https://www.gravatar.com/avatar/c4b707b3a5ffcad5b13b78c8da672952</icon>
  <subtitle>活到老，学到老</subtitle>
  <link href="http://14uy2u.coding-pages.com/atom.xml" rel="self"/>
  
  <link href="http://14uy2u.coding-pages.com/"/>
  <updated>2021-07-04T07:04:29.300Z</updated>
  <id>http://14uy2u.coding-pages.com/</id>
  
  <author>
    <name>Mosey</name>
    <email>1402843622@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx代理服务器</title>
    <link href="http://14uy2u.coding-pages.com/2021/05/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://14uy2u.coding-pages.com/2021/05/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-05-09T10:30:18.000Z</published>
    <updated>2021-07-04T07:04:29.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx是什么"><a class="header-anchor" href="#Nginx是什么">¶</a>Nginx是什么</h2><ul><li>一个高性能的<code>web代理服务器</code></li><li>nginx占用内存少、支持高并发，最高可达 5w 个并发量</li><li>开源，可用于商业用途，使用配置简单，中文社区也比较活跃</li><li>支持热部署 ，在不打断用户请求的情况下更新版本(⚠️是nginx版本，不是应用版本)</li></ul><h2 id="正向和反向代理区别"><a class="header-anchor" href="#正向和反向代理区别">¶</a>正向和反向代理区别</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/moshengxin/Blog-Picture@main/nginx/%E6%AD%A3%E5%8F%8D%E4%BB%A3%E7%90%86.6y2of3fqgts0.jpg" alt="区别"></p><h2 id="nginx配置文件理解"><a class="header-anchor" href="#nginx配置文件理解">¶</a>nginx配置文件理解</h2><ul><li>nginx默认的配置，也可以自行修改，换端口，换location的路径和index首页<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/moshengxin/Blog-Picture@main/nginx/%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE.3l3m5kj9x720.png" alt="默认配置"></li><li>再来一张菜鸟上面的截图，很详细<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/moshengxin/Blog-Picture@main/nginx/config.3xzdplv40rq0.jpg" alt="config"></li></ul><h2 id="nginx实现负载均衡的几种策略"><a class="header-anchor" href="#nginx实现负载均衡的几种策略">¶</a>nginx实现负载均衡的几种策略</h2><p><em>负载均衡其实就是利用多个服务器集群，将客户端的高并发请求分发到不同的服务器来减轻压力</em></p><ul><li>简单的集群配置<ul><li><strong>轮询(AB…AB…交替处理请求，相当于列表循环)</strong><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/moshengxin/Blog-Picture@main/nginx/%E9%9B%86%E7%BE%A41.386v5fvlw2w0.jpg" alt="简单集群"></li><li><strong>权重(weight)：</strong><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/moshengxin/Blog-Picture@main/nginx/weight.761b1wuvit00.jpg" alt="权重"></li><li><strong>IP绑定(ip_hash)</strong><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/moshengxin/Blog-Picture@main/nginx/ip_hash.4x58fei6mxe0.jpg" alt="IP绑定"></li><li><strong>服务响应时间最短(fair):</strong><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/moshengxin/Blog-Picture@main/nginx/fair.2eh1xuxxi3fo.jpg" alt="fair"></li><li><strong>当前连接最少(least_conn)</strong><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/moshengxin/Blog-Picture@main/nginx/least_conn.5pjvq3tpbr00.jpg" alt="least_conn"></li></ul></li></ul><h2 id="session共享问题"><a class="header-anchor" href="#session共享问题">¶</a>session共享问题</h2><ul><li>当同一个用户第一次访问tomcat_8111 并且登录成功， 而第二次访问却被分配到了tomcat_8222， 这里并没有记录他的登陆状态，那么就会呈现未登录状态了，严重伤害了用户体验。</li><li>解决办法：<code>使用ip_hash绑定策略</code></li><li></li></ul><h2 id="高可用"><a class="header-anchor" href="#高可用">¶</a>高可用</h2><h3 id="反向代理服务器高可用"><a class="header-anchor" href="#反向代理服务器高可用">¶</a>反向代理服务器高可用</h3><ol><li>当某一台服务器出现问题了，变成了down状态，我们要选择第二台服务器，所以我们在<code>location节点</code>下添加<code>proxy_connect_timeout 1</code>，目的是在连接超过1秒后(防止请求握手服务器失败后处于一直等待状态)，请求自动轮询到下一台没有宕机的服务器去。</li></ol><h3 id="nginx高可用"><a class="header-anchor" href="#nginx高可用">¶</a>nginx高可用</h3><ol><li>使用keepalived来设置主从nginx，防止nginx宕机事故的发生，nginx宕机后启动第二个nginx<br><a href="https://www.cnblogs.com/920913cheng/p/10484786.html">教程参考</a></li></ol><h2 id="nginx解决跨域"><a class="header-anchor" href="#nginx解决跨域">¶</a>nginx解决跨域</h2><ul><li>解决办法：在相对应的<code>location节点</code>中添加以下内容</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">add_header</span> <span class="string">Access-Control-Allow-Origin</span> <span class="string">*;</span></span><br><span class="line"><span class="string">add_header</span> <span class="string">Access-Control-Allow-Methods</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span><span class="string">;</span></span><br><span class="line"><span class="string">add_header</span> <span class="string">Access-Control-Allow-Headers</span> <span class="string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="string">if</span> <span class="string">($request_method</span> <span class="string">=</span> <span class="string">&#x27;OPTIONS&#x27;</span><span class="string">)</span> &#123;</span><br><span class="line">    <span class="string">return</span> <span class="number">204</span><span class="string">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nginx开启https协议"><a class="header-anchor" href="#nginx开启https协议">¶</a>nginx开启https协议</h2><ul><li>需要ssh证书，<a href="https://www.cnblogs.com/wl416896401/p/13903496.html">教程参考</a></li></ul><h2 id="nginx静态资源部署-动静分离"><a class="header-anchor" href="#nginx静态资源部署-动静分离">¶</a>nginx静态资源部署(动静分离)</h2><ul><li>将静态资源部署在 <code>Nginx</code> 上(即：html页面放在nginx安装目录下的html文件夹中，图片等静态资源要在配置文件中的<code>server节点中的location节点中配置</code>)</li><li>动态资源请求(一般为需要查接口查数据库的资源)则利用nginx做反向代理去对应的服务器后台获取数据<br><em>使用前后端动静分离后，可提升静态资源的访问速度（因为不要查后台），即使动态服务不可用，静态资源的访问也不会受到影响。</em></li></ul><h2 id="补充"><a class="header-anchor" href="#补充">¶</a>补充</h2><p>linux系统中，http请求默认端口是80，而nginx配置文件中默认的端口也是80，所以没有改端口的情况下，访问linux的ip，默认也是80端口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nginx是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Nginx是什么&quot;&gt;¶&lt;/a&gt;Nginx是什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个高性能的&lt;code&gt;web代理服务器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;nginx占用内存少、支持高并</summary>
      
    
    
    
    <category term="服务器" scheme="http://14uy2u.coding-pages.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="nginx" scheme="http://14uy2u.coding-pages.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器</title>
    <link href="http://14uy2u.coding-pages.com/2021/05/05/container/docker%E5%AE%B9%E5%99%A8/"/>
    <id>http://14uy2u.coding-pages.com/2021/05/05/container/docker%E5%AE%B9%E5%99%A8/</id>
    <published>2021-05-05T14:55:23.000Z</published>
    <updated>2021-05-10T03:25:03.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>==欢迎来访我的个人博客== ：<a href="http://14uy2u.coding-pages.com/">Mosey</a></li></ul><h1>Docker是什么</h1><ul><li>Docker 将应用程序与该程序的依赖(可理解为运行环境和软件支持，如mysql、redis、nginx、es、mq等等)，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</li><li>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</li></ul><h1>Docker有什么用</h1><ul><li>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</li><li>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</li></ul><h1>Docker优点</h1><ul><li><code>启动快</code>、<code>资源占用小</code>、<code>体积小</code></li></ul><h1>Docker应用场景(什么时候用)</h1><ul><li>Web 应用的自动化打包和发布<ul><li>如果要发布应用到几十台甚至几百台服务器时，利用docker可大大提高效率。</li></ul></li><li>自动化测试和持续集成、发布、快速交付软件给用户。<ul><li>合作开发的时候，在本机可以跑，别人的电脑跑不起来，如果利用docker把应用依赖的所有环境(java、tomcat、redis等)都打成一个镜像，直接丢给别人的电脑上就能运行起来，很方便。</li></ul></li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li></ul><h1>Docker怎么用</h1><h2 id="Docker三个概念"><a class="header-anchor" href="#Docker三个概念">¶</a>Docker三个概念</h2><h3 id="镜像"><a class="header-anchor" href="#镜像">¶</a>镜像</h3><ul><li>镜像不包含任何动态数据，其内容在构建之后也不会改变(可理解为web应用运行时需要的环境)</li><li>镜像有多个tag，也就是说多个版本，比如java有多个版本，redis也有多个版本这样，我们docker pull image时可以指定tag版本(docker pull java:8)，不指定则默认最新版本latest。</li></ul><h3 id="容器"><a class="header-anchor" href="#容器">¶</a>容器</h3><ul><li>容器是用镜像创建的运行实例，一个镜像可以创建多个容器。</li><li>容器之间相互隔离，保证应用运行期间的安全。</li></ul><h3 id="仓库"><a class="header-anchor" href="#仓库">¶</a>仓库</h3><ul><li>仓库（Repository）是集中存放镜像文件的场所，类似github。</li></ul><h2 id="数据卷-volume"><a class="header-anchor" href="#数据卷-volume">¶</a>数据卷(volume)</h2><ul><li>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统</li><li>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</li><li><code>docker run -it -v /宿主机目录:/容器内目录</code>命令中的<code>-v</code>后面跟着的就是数据卷<ul><li>特点：<br>1：数据卷可在容器之间共享或重用数据<br>2：卷中的更改可以直接生效<br>3：数据卷中的更改不会包含在镜像的更新中<br>4：数据卷的生命周期一直持续到没有容器使用它为止</li></ul></li></ul><h2 id="Docker目录简析"><a class="header-anchor" href="#Docker目录简析">¶</a>Docker目录简析</h2><ul><li>/var/lib/docker/image/overlay2/repositories.json里边存的是镜像，对应docker images命令结果</li><li>/var/lib/docker/image/overlay2/imagedb/content/sha256里边存放的是历史镜像id文件(包括已删除的)，vi 镜像id 可查看相关信息</li><li></li></ul><h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2><p><a><b> <a href="https://www.jianshu.com/p/80e3fd18a17e">ubuntu安装docker教程</a></b></a></p><h2 id="常用命令"><a class="header-anchor" href="#常用命令">¶</a>常用命令</h2><h3 id="Docker启动相关命令"><a class="header-anchor" href="#Docker启动相关命令">¶</a>Docker启动相关命令</h3><p><a><b> docker启动</b></a></p><blockquote><p>systemctl start docker    # 方法一<br>docker         # 方法二<br>docker start $(docker ps -a | awk ‘{ print $1}’ | tail -n +2) #启动所有容器</p></blockquote><p><a><b> 查看docker是否正在运行【Active: <font color="green">active (running)</font>运行状态 】<br>【Active: inactive (dead) 停止状态】</b></a></p><blockquote><p>systemctl status docker</p></blockquote><p><a><b> 关闭docker</b></a></p><blockquote><p>systemctl stop docker</p></blockquote><p><a><b> 重启docker</b></a></p><blockquote><p>systemctl restart docker</p></blockquote><p><a><b> 查看Docker版本</b></a></p><blockquote><p>docker version   或者  docker info</p></blockquote><h3 id="镜像相关命令"><a class="header-anchor" href="#镜像相关命令">¶</a>镜像相关命令</h3><p><a><b> 搜索仓库中的java镜像</b></a></p><blockquote><p>docker search java</p></blockquote><p><a><b> 从仓库中拉取java镜像到本地</b></a></p><blockquote><p>docker pull java     # 不指定java版本号<br>docker pull java:8   # 指定java8版本</p></blockquote><p><a><b> 查看所有镜像</b></a></p><blockquote><p>docker images</p></blockquote><p><a><b> 删除镜像</b></a></p><blockquote><p>docker rmi 镜像NAME</p></blockquote><p><a><b> 强制删除所有镜像</b></a></p><blockquote><p>docker rmi -f $(docker images)</p></blockquote><p><a><b> 镜像打包成tar包</b></a></p><blockquote><p>docker image save 镜像NAME/ID &gt; 镜像.tar</p></blockquote><p><a><b> tar包还原成镜像(导入镜像)</b></a></p><blockquote><p>docker image load &lt; 镜像.tar</p></blockquote><p><a><b> 项目打包成镜像(-t 表示指定镜像仓库名称/镜像名称:镜像标签版本 .表示使用当前目录下的Dockerfile文件)</b></a></p><blockquote><p>docker build -t mall/mall-admin:1.0-SNAPSHOT  .</p></blockquote><h3 id="容器相关命令"><a class="header-anchor" href="#容器相关命令">¶</a>容器相关命令</h3><p><a><b> 利用tomcat镜像新建并启动容器</b></a></p><ul><li>-d：后台运行，格式：<code>-d 容器名:容器tag(版本)</code></li><li>–name：指定运行后容器的名字为tomcat,之后可以通过名字来操作容器，格式：<code>--name 容器NAME</code></li><li>-p：指定端口映射，格式为：<code>-p 宿主机端口:容器端口</code>，将容器端口映射到主机的端口</li><li>后面的:8.0.52为tomcat版本号(tag)，不指定则默认latest最新版本</li><li>下面的命令指：在后台启动运行一个名为“tomcat-name”的容器，访问localhost:1234可访问tomcat首页</li></ul><blockquote><p>docker run --name tomcat-name -d -p 1234:8080 tomcat:8.0.52  #这里版本为8.0.52，8.5版本的貌似没有启动首页，所以不能访问tomcat首页<br>* 如果要挂载一个指定目录到宿主机上，则使用<code>-v</code> ，格式：<code>-v 宿主机目录:容器目录(也叫数据卷)</code><br>* 如果要连接到另一个容器相依赖，则使用<code>--link</code>(比如某个项目启动依赖mysql数据库)，格式：<code>--link 容器NAME:自定义容器别名</code></p></blockquote><p><a><b> 一键启动所有容器(无依赖项的容器)</b></a></p><ul><li>因有的容器启动需要依赖其它的容器服务(有先后顺序)，所以会启动失败。<ul><li>解决办法：</li></ul></li></ul><blockquote><p>docker start 失败容器NAME/ID</p></blockquote><p><a><b> 一键关闭所有容器</b></a></p><blockquote><p>docker stop $(docker ps -a | awk ‘{ print $1}’ | tail -n +2)</p></blockquote><p><a><b> 查看所有容器</b></a></p><blockquote><p>docker ps -a</p></blockquote><p><a><b> 进入正在运行的容器内部bash(执行下面命令后，再执行ls -l可看容器内的文件和文件夹)</b></a></p><blockquote><p>docker exec -it 容器NAME/ID /bin/bash #相当于进入对应的安装根目录</p></blockquote><p><a><b> 停止容器</b></a></p><blockquote><p>docker stop 容器NAME/ID</p></blockquote><p><a><b> 停止所有正在运行的容器</b></a></p><blockquote><p>docker stop $(docker ps -q)</p></blockquote><p><a><b> 删除容器(只能删除停止的容器，正在运行的容器会删除失败)</b></a></p><blockquote><p>docker rm 容器NAME/ID</p></blockquote><p><a><b> 删除所有容器</b></a></p><blockquote><p>docker rm $(docker ps -aq)</p></blockquote><p><a><b> 查看容器运行日志</b></a></p><blockquote><p>docker logs 容器NAME/ID</p></blockquote><p><a><b> 动态查看容器运行日志</b></a></p><blockquote><p>docker logs 容器NAME/ID -f</p></blockquote><p><a><b> 查看容器IP地址</b></a></p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">docker inspect --<span class="keyword">format</span> <span class="string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> 容器NAME/ID</span><br></pre></td></tr></table></figure><p><a><b> 监控容器资源消耗</b></a></p><blockquote><p>docker stats 容器NAME/ID</p></blockquote><p><a><b> 监控所有容器资源消耗(cpu、内存、io、网络等)</b></a></p><blockquote><p>docker stats 容器NAME/ID -a</p></blockquote><p><a><b> 查看docker占用磁盘大小(根据镜像、容器)</b></a></p><blockquote><p>docker system df</p></blockquote><p><a><b> 具体查看每个镜像和容器占用磁盘大小</b></a></p><blockquote><p>docker system df -v</p></blockquote><h1>Docker展现了什么效果</h1><ul><li>当把SpringBoot项目所有要的环境(redis、es、mongodb等，配置好相关的ip、端口、es账号等)和数据(.sql文件导入到mysql镜像中)准备好，就可以用maven插件(pom.xml中配置好Docker的ip和端口)打包成Docker镜像文件，在Docker那边就可以把image镜像文件运行为容器，这一系列操作下来，项目第一次升级成功，客户就可以远程访问了。</li><li>可以把自己配置好的镜像打包成tar包，然后发给同事或者测试运维人员，他们再把tar解压到docker中去就能使用了。免去麻烦的配置过程。</li><li>下载Pull镜像方便，容器启动也快速等等。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;==欢迎来访我的个人博客== ：&lt;a href=&quot;http://14uy2u.coding-pages.com/&quot;&gt;Mosey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Docker是什么&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Docker 将应用程序与该程序的依赖(可理解为</summary>
      
    
    
    
    <category term="容器化" scheme="http://14uy2u.coding-pages.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://14uy2u.coding-pages.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>部署mall项目爬坑日记</title>
    <link href="http://14uy2u.coding-pages.com/2021/05/03/%E9%83%A8%E7%BD%B2mall%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://14uy2u.coding-pages.com/2021/05/03/%E9%83%A8%E7%BD%B2mall%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-05-03T06:45:23.000Z</published>
    <updated>2021-07-04T07:05:00.258Z</updated>
    
    <content type="html"><![CDATA[<h1>部署mall项目爬坑日记</h1><p><a href="https://github.com/macrozheng/mall">原作者项目</a><br><em>环境：ubuntu20</em></p><h2 id="docker容器相关的坑"><a class="header-anchor" href="#docker容器相关的坑">¶</a>docker容器相关的坑</h2><h3 id="发现容器打印的日志和当前时间有出入，相差了8小时，后面得知容器和宿主机的时区不同导致"><a class="header-anchor" href="#发现容器打印的日志和当前时间有出入，相差了8小时，后面得知容器和宿主机的时区不同导致">¶</a>发现容器打印的日志和当前时间有出入，相差了8小时，后面得知容器和宿主机的时区不同导致</h3><ul><li>解决办法有如下几种：<ul><li>1.在刚开始创建容器的时候，docker run后面加上<code>-v /etc/localtime:/etc/localtime:ro</code></li><li>2.已创建的容器运行(没有/etc/localtime)，<code>docker cp /etc/localtime 容器NAME:/etc/</code></li><li>3.进入已创建的容器内(有/etc/localtime)，先删除容器内的localtime文件<code>rm /etc/localtime</code> 再关联运行<code>ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></li></ul></li></ul><h3 id="发现宿主机的端口和容器端口相同冲突"><a class="header-anchor" href="#发现宿主机的端口和容器端口相同冲突">¶</a>发现宿主机的端口和容器端口相同冲突</h3><ul><li>问题：因为宿主机之前有安装mysql和redis，并设置了开机自启，所以在启动mysql和redis容器时，会报错<code>Error starting userland proxy: listen tcp4 0.0.0.0:端口号: bind: address already in use</code></li><li>解决办法有两种：<ul><li>1.<code>systemctl stop 服务名</code>停止相关服务，再启动容器</li><li>2.docker run创建容器的时候，更换不同宿主机端口</li></ul></li></ul><h3 id="SpringBoot中mysql和redis的IP指向问题"><a class="header-anchor" href="#SpringBoot中mysql和redis的IP指向问题">¶</a>SpringBoot中mysql和redis的IP指向问题</h3><ul><li>问题：看到yml配置中的mysql和redis的IP地址分别是<code>db</code>和<code>redis</code>两个变量，全局搜索也找不到指定的是哪个IP</li><li>解决：<ul><li>是因为mall项目用maven打包成镜像后，docker run 启动的时候要<code>--link</code>关联mysql容器的redis容器，具体看下图可知指向的是linux服务器的IP 😂<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/7e05ffa716a8e6600c3dbda6a58a4169.png" alt="配置文件"></li></ul></li></ul><h2 id="数据库相关的坑"><a class="header-anchor" href="#数据库相关的坑">¶</a>数据库相关的坑</h2><h3 id="库中数据正常，但前端页面文字显示乱码"><a class="header-anchor" href="#库中数据正常，但前端页面文字显示乱码">¶</a>库中数据正常，但前端页面文字显示乱码</h3><ul><li>思路：<ul><li>1.status 命令查看数据库mall编码，发现编码是latinl并不是utf8，于是用<code>set xxx=utf8</code>逐个改成下面格式，并重启mysql服务，重启mysql容器重试后，再次查看数据库编码还原成原来的latinal编码了，治标不治本。前端还是乱码，失败。</li></ul></li></ul><table><thead><tr><th style="text-align:left">character_set_client</th><th style="text-align:left">utf8</th></tr></thead><tbody><tr><td style="text-align:left">character_set_client</td><td style="text-align:left">utf8</td></tr><tr><td style="text-align:left">character_set_connection</td><td style="text-align:left">utf8</td></tr><tr><td style="text-align:left">character_set_database</td><td style="text-align:left">utf8</td></tr><tr><td style="text-align:left">character_set_filesystem</td><td style="text-align:left">binary</td></tr><tr><td style="text-align:left">character_set_results</td><td style="text-align:left">utf8</td></tr><tr><td style="text-align:left">character_set_server</td><td style="text-align:left">utf8</td></tr><tr><td style="text-align:left">character_set_system</td><td style="text-align:left">utf8</td></tr><tr><td style="text-align:left">character_sets_dir</td><td style="text-align:left">/usr/share/mysql/charsets/</td></tr></tbody></table><ul><li>2.添加mysql配置文件my.cnf，并指定下面内容编码，重启后查看mysql编码已成功改为utf8，但是前端还是乱码。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line"><span class="keyword">default</span>-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br></pre></td></tr></table></figure><ul><li>最终解决方法：<ul><li><p>1.删除mall数据库，重新创建mall数据库，创建时候使用命令<code>create  database mall character  set utf8</code>指定编码,并导入mall.sql数据。</p></li><li><p>2.停止并删除相关容器，删除相关镜像，再重新用idea生成镜像，重新创建容器。</p></li></ul></li><li><a>乱码原因：<ul><li><u>创建数据库时没有指定utf8编码</u></li></ul></a></li></ul><h2 id="防火墙相关坑"><a class="header-anchor" href="#防火墙相关坑">¶</a>防火墙相关坑</h2><h3 id="没有开放mall项目相关端口"><a class="header-anchor" href="#没有开放mall项目相关端口">¶</a>没有开放mall项目相关端口</h3><ul><li>没有开放mall项目相关端口，项目部署成功却不能访问</li><li>解决办法：<code>firewall-cmd --zone=public --add-port=端口号/tcp --permanent</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;部署mall项目爬坑日记&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/macrozheng/mall&quot;&gt;原作者项目&lt;/a&gt;&lt;br&gt;
&lt;em&gt;环境：ubuntu20&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker容器相关的坑&quot;&gt;&lt;a class=</summary>
      
    
    
    
    <category term="项目部署" scheme="http://14uy2u.coding-pages.com/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="linux" scheme="http://14uy2u.coding-pages.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Jvm了解一下</title>
    <link href="http://14uy2u.coding-pages.com/2021/05/01/java/jvm%E6%95%B4%E7%90%86/"/>
    <id>http://14uy2u.coding-pages.com/2021/05/01/java/jvm%E6%95%B4%E7%90%86/</id>
    <published>2021-05-01T04:34:22.000Z</published>
    <updated>2021-07-04T06:55:18.569Z</updated>
    
    <content type="html"><![CDATA[<ul><li>==欢迎来访我的个人博客== ：<a href="https://moshengxin.github.io/">Mosey</a></li></ul><h1>jre jdk jvm三者区别</h1><ul><li>Jdk是Java 开发工具包，jdk文件夹下面的bin目录有提供一些工具程序，比如：<code>java.exe</code>、<code>javac.exe</code>、<code>javadoc.exe</code>等等</li><li>Jre是java运行时环境</li><li>Jvm是java虚拟机</li><li>Jdk包含Jre，Jre包含Jvm</li></ul><h1>.java后缀文件运行</h1><ul><li>1.<code>javac xxx.java</code>命令把.java文件编译成<code>.class字节码文件</code></li><li>2.<code>java xxx</code>命令把字节码文件放到Jvm中执行代码程序</li></ul><h2 id="java跨平台性"><a class="header-anchor" href="#java跨平台性">¶</a>java跨平台性</h2><p>JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。编译虚拟机的指令集与编译微处理器的指令集非常类似。<br>JVM是Java语言跨平台（这里的“平台”是指不同的操作系统）的基础，要想在不同的操作系统上运行Java程序，就需要在不同操作系统上安装对应的JVM。所以，JVM有Windows版本、MAC版本、Linux版本等。</p><h2 id="jvm一些理解"><a class="header-anchor" href="#jvm一些理解">¶</a>jvm一些理解</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/moshengxin/Blog-Picture@main/jvm%E6%95%B4%E7%90%86/jvm.14kc2xhmlpy8.jpg" alt></p><ul><li><code>-Xmx(最大堆内存)</code>、<code>-Xms(最小堆内存)</code>这两个jvm调优参数，是对堆进行控制的，如果内存不足，就报<code>OutOfMemoryError:java heap space异常</code>。</li><li>堆和方法区是共享的，</li><li><code>jps命令</code>查看当前用户的Java进程，非系统中所有的进程。</li></ul><h2 id="队列和栈的区别"><a class="header-anchor" href="#队列和栈的区别">¶</a>队列和栈的区别</h2><ul><li>队列的插入叫入队，队列的删除叫出队。栈的插入叫进栈，栈的删除叫出栈。</li><li>队列在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</li><li>队列是先进先出，栈为先进后出</li></ul><h2 id="双亲委派机制"><a class="header-anchor" href="#双亲委派机制">¶</a>双亲委派机制</h2><ul><li><strong>理解</strong>：在类加载的时候，类加载器要加载编译后的.class文件，这时，类编译器会首先向上级类加载器请求访问有没有加载过，有加载过就不用自己加载，如果都没有找到，就会报<code>ClassNotFoundException</code></li><li><strong>好处</strong>：保证类不被轻易纂改，数据安全</li><li><strong>各个类加载器级别</strong>：从小到大<ul><li>1、BootStrap ClassLoader：rt.jar</li><li>2、Extension ClassLoader: 加载扩展的jar包</li><li>3、App ClassLoader：指定的classpath下面的jar包</li><li>4、Custom ClassLoader：自定义的类加载器</li></ul></li></ul><h2 id="类加载顺序"><a class="header-anchor" href="#类加载顺序">¶</a>类加载顺序</h2><p>加载、连接(验证+准备+解析)、初始化、使用、卸载。</p><ul><li><p>加载：加载.class文件；</p></li><li><p>验证：检查.class文件是否正确；</p></li><li><p>准备：给类分配一定的内存空间；</p></li><li><p>解析：将常量池内的符号引用替换为直接引用；</p></li><li><p>初始化：执行 static 代码块进行初始化，如果存在父类，先对父类进行初始化；</p></li><li><p>使用：为对象分配内存空间和初始化；</p></li><li><p>卸载：GC回收类对象。</p></li></ul><h2 id="判断对象是否存活"><a class="header-anchor" href="#判断对象是否存活">¶</a>判断对象是否存活</h2><ol><li><strong>引用计数法</strong></li><li><strong>可达性分析</strong></li></ol><h2 id="垃圾回收算法"><a class="header-anchor" href="#垃圾回收算法">¶</a>垃圾回收算法</h2><ul><li><strong>标记清除、复制算法、标记整理</strong>三种算法</li></ul><h2 id="GC调优或Jvm调优"><a class="header-anchor" href="#GC调优或Jvm调优">¶</a>GC调优或Jvm调优</h2><ul><li>一般项目加个 <code>xms</code> 和 <code>xmx</code> 参数就够了。在没有全面监控、收集性能数据之前，调优就是瞎调。</li></ul><h2 id="调优工具"><a class="header-anchor" href="#调优工具">¶</a>调优工具</h2><ul><li>一些JDK自带命令<code>jps</code>、<code>jstat</code>、<code>jmap</code>、<code>jhat</code>等</li><li>有兴趣可以去了解一下阿里出品的java诊断调优神器<code>Arthas</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;==欢迎来访我的个人博客== ：&lt;a href=&quot;https://moshengxin.github.io/&quot;&gt;Mosey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;jre jdk jvm三者区别&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Jdk是Java 开发工具包，jdk文件</summary>
      
    
    
    
    <category term="Jvm" scheme="http://14uy2u.coding-pages.com/categories/Jvm/"/>
    
    
    <category term="优化" scheme="http://14uy2u.coding-pages.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>妈妈我想学Sql性能优化</title>
    <link href="http://14uy2u.coding-pages.com/2021/04/21/DataBase/Explain%E6%9F%A5%E8%AF%A2Sql%E6%95%88%E7%8E%87/"/>
    <id>http://14uy2u.coding-pages.com/2021/04/21/DataBase/Explain%E6%9F%A5%E8%AF%A2Sql%E6%95%88%E7%8E%87/</id>
    <published>2021-04-21T14:12:20.000Z</published>
    <updated>2021-05-10T03:35:36.505Z</updated>
    
    <content type="html"><![CDATA[<ul><li>==欢迎来访我的个人博客== ：<a href="http://14uy2u.coding-pages.com/">Mosey</a></li></ul><h1>Explain分析Sql性能</h1><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>在我们平时开发中，因为系统可能属于初级阶段，数据库的数据还不是很多，所以自我感觉写的Sql语句上运行起来速度还不错，殊不知，随着时间推移，数据量日益增多，系统的查询效率会在打折扣，所以，Sql性能调优手段还得了解一下下。</p><h2 id="Explain是什么？有什么用？"><a class="header-anchor" href="#Explain是什么？有什么用？">¶</a>Explain是什么？有什么用？</h2><ul><li>Explain可以用来分析一条Sql语句的运行效率。根据执行后的结果字段来判断查询有没有用“索引”、“全表扫描还是只扫描一些行”、“当前sql处于哪个性能级别”等等。</li></ul><h2 id="Explain怎么用？"><a class="header-anchor" href="#Explain怎么用？">¶</a>Explain怎么用？</h2><ul><li>用法：<code>explain 待分析的Sql语句</code></li></ul><h2 id="Explain返回字段了解一下"><a class="header-anchor" href="#Explain返回字段了解一下">¶</a>Explain返回字段了解一下</h2><ul><li><a><b>id</b></a></li></ul><blockquote><p><code>id</code>越大，越先执行(单表Sql除外)，id相同，则执行顺序由上而下</p></blockquote><ul><li><a><b>select_type(查询类型)<ul><li>只列举其中几种</li></ul></b></a></li></ul><blockquote><p><code>simple</code>： 简单select(无union或where子查询)<br><code>primary</code>： 最外层select<br><code>subquery</code>：子查询中中第一个select</p></blockquote><ul><li><a><b>table</b></a></li></ul><blockquote><p>Sql查询对应的数据库表名称</p></blockquote><ul><li><a><b>partitions(分区)</b></a></li><li><a><b>type(联接类型)<ul><li>可根据type知道sql的性能级别，all性能最差(全表扫描)，</li><li>我们平时开发写的Sql至少达到range性能级别，最好能达到ref，不然有可能出现性能问题</li><li>性能级别天梯如下</li></ul></b></a></li></ul><blockquote><p><code>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; all</code></p></blockquote><ul><li><a><b>possible_keys</b></a></li></ul><blockquote><p>查询时，<code>可能用到的索引</code></p></blockquote><ul><li><a><b>key</b></a></li></ul><blockquote><p>查询时，<code>真正用到的索引</code></p></blockquote><ul><li><a><b>key_len</b></a></li></ul><blockquote><p>可片面理解为索引长度，不过不是真正的长度，Sql自有一套计算长度规则</p></blockquote><ul><li><a><b>rows</b></a></li></ul><blockquote><p>扫描了多少行。</p></blockquote><ul><li><a><b>extra(额外信息)</b></a></li></ul><blockquote><p>是否使用索引 ，是否使用where，是否使用distinct等待<br>性能级别：useing index&gt;usinh where &gt; using temporary | using filesort</p></blockquote><h2 id="实战小例子"><a class="header-anchor" href="#实战小例子">¶</a>实战小例子</h2><ul><li>没加索引前<br><a href="https://imgtu.com/i/cRzilD"><img src= "/img/loading.gif" data-lazy-src="https://z3.ax1x.com/2021/04/16/cRzilD.png" alt="cRzilD.png"></a></li><li>在t_erchang_sanjian_user表的user_name字段加了索引后<br><a href="https://imgtu.com/i/cWSVvF"><img src= "/img/loading.gif" data-lazy-src="https://z3.ax1x.com/2021/04/16/cWSVvF.png" alt="cWSVvF.png"></a></li><li>又在t_erchang_sanjian_photo表中的create_by字段加了索引后<br><a href="https://imgtu.com/i/cW9Z79"><img src= "/img/loading.gif" data-lazy-src="https://z3.ax1x.com/2021/04/16/cW9Z79.png" alt="cW9Z79.png"></a></li></ul><h2 id="写Sql时要注意点什么"><a class="header-anchor" href="#写Sql时要注意点什么">¶</a>写Sql时要注意点什么</h2><ul><li>where后面的字段的值要加单引号<code>‘’</code>不然如果该字段有索引，则索引失效</li><li>join连接多表(两到三个表最优)查询时，每个表设置别名，字段也用别名.字段表示</li><li>有大量重复数据的字段不适合创建索引，如性别(男，女)，是否删除(0,1)这类型字段。</li><li>虽然索引能加快查询速度，但是建议单表最多设置5个索引，因为索引太多会影响插入和更新速度</li><li>避免同时修改或删除大量数据，这样会造成cpu飙升，从而影响别人对数据库的访问</li><li>删除重复索引，如果字段A和B创建了组合索引，那么就不必要单独为A再创建新的索引了（index_A_B相当于创建了A,AB索引，即最左匹配原则）。</li><li>如果要插入大量数据，建议分批插入</li><li>建议在where和order by涉及的列上建立组合索引</li><li>连接查询相关：<ul><li><p>Inner join 只保留两张表中完全匹配的结果集</p></li><li><p>left join 返回左表所有的行，即使在右表中没有匹配的记录。</p></li><li><p>right join 返回右表所有的行，即使在左表中没有匹配的记录。</p></li></ul></li><li>避免在索引列上使用mysql的内置函数，如(时间类函数等)</li><li>不寻底常用select *，应该要明确要查的具体字段</li><li>平时开发中，可日志打印一下完整sql放到数据库客户端运行一下排错</li><li>存储引擎中，<ul><li>MyISAM支持表级锁，不支持事务和全文索引</li><li>InnoDB支持行级锁、支持事务安全（ACID兼容）、支持外键</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;==欢迎来访我的个人博客== ：&lt;a href=&quot;http://14uy2u.coding-pages.com/&quot;&gt;Mosey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Explain分析Sql性能&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header</summary>
      
    
    
    
    <category term="数据库" scheme="http://14uy2u.coding-pages.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="优化" scheme="http://14uy2u.coding-pages.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>高并发下如何保证接口的幂等性？</title>
    <link href="http://14uy2u.coding-pages.com/2021/04/17/java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>http://14uy2u.coding-pages.com/2021/04/17/java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2021-04-17T11:40:18.000Z</published>
    <updated>2021-07-04T07:05:50.198Z</updated>
    
    <content type="html"><![CDATA[<p>好文章怕丢失?码起来!<br><a>本文转载自<a href="https://blog.csdn.net/lisu061714112/article/details/115313913">原文</a></a></p><h2 id="高并发下如何保证接口的幂等性？"><a class="header-anchor" href="#高并发下如何保证接口的幂等性？">¶</a>高并发下如何保证接口的幂等性？</h2><p><code>接口幂等性</code>问题，对于开发人员来说，是一个跟语言无关的公共问题。本文分享了一些解决这类问题非常实用的办法，绝大部分内容我在项目中实践过的，给有需要的小伙伴一个参考。</p><p>不知道你有没有遇到过这些场景：</p><ol><li><p>有时我们在填写某些<code>form表单</code>时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是id不一样。</p></li><li><p>我们在项目中为了解决<code>接口超时</code>问题，通常会引入了<code>重试机制</code>。第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），为了避免返回错误的结果（这种情况不可能直接返回失败吧？），于是会对该请求重试几次，这样也会产生重复的数据。</p></li><li><p>mq消费者在读取消息时，有时候会读取到<code>重复消息</code>（至于什么原因这里先不说，有兴趣的小伙伴，可以找我私聊），如果处理不好，也会产生重复的数据。</p></li></ol><p>没错，这些都是幂等性问题。</p><p><code>接口幂等性</code>是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。</p><p>这类问题多发于接口的：</p><ul><li><p><code>insert</code>操作，这种情况下多次请求，可能会产生重复数据。</p></li><li><p><code>update</code>操作，如果只是单纯的更新数据，比如：<code>update user set status=1 where id=1</code>，是没有问题的。如果还有计算，比如：<code>update user set status=status+1 where id=1</code>，这种情况下多次请求，可能会导致数据错误。</p></li></ul><p>那么我们要如何保证接口幂等性？本文将会告诉你答案。</p><h2 id="1、insert前先select"><a class="header-anchor" href="#1、insert前先select">¶</a>1、insert前先select</h2><p>通常情况下，在保存数据的接口中，我们为了防止产生重复数据，一般会在<code>insert</code>前，先根据<code>name</code>或<code>code</code>字段<code>select</code>一下数据。如果该数据已存在，则执行<code>update</code>操作，如果不存在，才执行  <code>insert</code>操作。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/dc1073f79704c69321e9303187007c4d.png" alt="图片"></p><p>该方案可能是我们平时在防止产生重复数据时，使用最多的方案。但是该方案不适用于并发场景，在并发场景中，要配合其他方案一起使用，否则同样会产生重复数据。我在这里提一下，是为了避免大家踩坑。</p><h2 id="2、加悲观锁"><a class="header-anchor" href="#2、加悲观锁">¶</a>2、加悲观锁</h2><p>在支付场景中，用户A的账号余额有150元，想转出100元，正常情况下用户A的余额只剩50元。一般情况下，sql是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user amount &#x3D; amount-100 where id&#x3D;123;</span><br></pre></td></tr></table></figure><p>如果出现多次相同的请求，可能会导致用户A的余额变成负数。这种情况，用户A来可能要哭了。于此同时，系统开发人员可能也要哭了，因为这是很严重的系统bug。</p><p>为了解决这个问题，可以加悲观锁，将用户A的那行数据锁住，在同一时刻只允许一个请求获得锁，更新数据，其他的请求则等待。</p><p>通常情况下通过如下sql锁住单行数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user id&#x3D;123 for update;</span><br></pre></td></tr></table></figure><p>具体流程如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/4811d12fd82a483f05a2629dbd3be299.png" alt="图片"></p><p>具体步骤：</p><ol><li><p>多个请求同时根据id查询用户信息。</p></li><li><p>判断余额是否不足100，如果余额不足，则直接返回余额不足。</p></li><li><p>如果余额充足，则通过for update再次查询用户信息，并且尝试获取锁。</p></li><li><p>只有第一个请求能获取到行锁，其余没有获取锁的请求，则等待下一次获取锁的机会。</p></li><li><p>第一个请求获取到锁之后，判断余额是否不足100，如果余额足够，则进行update操作。</p></li><li><p>如果余额不足，说明是重复请求，则直接返回成功。</p></li></ol><blockquote><p>需要特别注意的是：如果使用的是mysql数据库，存储引擎必须用innodb，因为它才支持事务。此外，这里id字段一定要是主键或者唯一索引，不然会锁住整张表。</p></blockquote><p>悲观锁需要在同一个事务操作过程中锁住一行数据，如果事务耗时比较长，会造成大量的请求等待，影响接口性能。</p><p>此外，每次请求接口很难保证都有相同的返回值，所以不适合幂等性设计场景，但是在防重场景中是可以的使用的。</p><p>在这里顺便说一下，<code>防重设计</code> 和 <code>幂等设计</code>，其实是有区别的。防重设计主要为了避免产生重复数据，对接口返回没有太多要求。而幂等设计除了避免产生重复数据之外，还要求每次请求都返回一样的结果。</p><h2 id="3、加乐观锁"><a class="header-anchor" href="#3、加乐观锁">¶</a>3、加乐观锁</h2><p>既然悲观锁有性能问题，为了提升接口性能，我们可以使用乐观锁。需要在表中增加一个<code>timestamp</code>或者<code>version</code>字段，这里以<code>version</code>字段为例。</p><p>在更新数据之前先查询一下数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,amount,version from user id&#x3D;123;</span><br></pre></td></tr></table></figure><p>如果数据存在，假设查到的<code>version</code>等于<code>1</code>，再使用<code>id</code>和<code>version</code>字段作为查询条件更新数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set amount&#x3D;amount+100,version&#x3D;version+1</span><br></pre></td></tr></table></figure><p>更新数据的同时<code>version+1</code>，然后判断本次<code>update</code>操作的影响行数，如果大于0，则说明本次更新成功，如果等于0，则说明本次更新没有让数据变更。</p><p>由于第一次请求<code>version</code>等于<code>1</code>是可以成功的，操作成功后<code>version</code>变成<code>2</code>了。这时如果并发的请求过来，再执行相同的sql：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set amount&#x3D;amount+100,version&#x3D;version+1</span><br></pre></td></tr></table></figure><p>该<code>update</code>操作不会真正更新数据，最终sql的执行结果影响行数是<code>0</code>，因为<code>version</code>已经变成<code>2</code>了，<code>where</code>中的<code>version=1</code>肯定无法满足条件。但为了保证接口幂等性，接口可以直接返回成功，因为<code>version</code>值已经修改了，那么前面必定已经成功过一次，后面都是重复的请求。</p><p>具体流程如下：<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/449f50a6da65b1cbab3485d19dbea558.png" alt="图片"></p><p>具体步骤：</p><ol><li><p>先根据id查询用户信息，包含version字段</p></li><li><p>根据id和version字段值作为where条件的参数，更新用户信息，同时version+1</p></li><li><p>判断操作影响行数，如果影响1行，则说明是一次请求，可以做其他数据操作。</p></li><li><p>如果影响0行，说明是重复请求，则直接返回成功。</p></li></ol><h2 id="4、加唯一索引"><a class="header-anchor" href="#4、加唯一索引">¶</a>4、加唯一索引</h2><p>绝大数情况下，为了防止重复数据的产生，我们都会在表中加唯一索引，这是一个非常简单，并且有效的方案。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table &#96;order&#96; add UNIQUE KEY &#96;un_code&#96; (&#96;code&#96;);</span><br></pre></td></tr></table></figure><p>加了唯一索引之后，第一次请求数据可以插入成功。但后面的相同请求，插入数据时会报<code>Duplicate entry '002' for key 'order.un_code</code>异常，表示唯一索引有冲突。</p><p>虽说抛异常对数据来说没有影响，不会造成错误数据。但是为了保证接口幂等性，我们需要对该异常进行捕获，然后返回成功。</p><p>如果是<code>java</code>程序需要捕获：<code>DuplicateKeyException</code>异常，如果使用了<code>spring</code>框架还需要捕获：<code>MySQLIntegrityConstraintViolationException</code>异常。</p><p>具体流程图如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/23d6d3dd1d70f740aea444f4eafbda0d.png" alt="图片"></p><p>具体步骤：</p><ol><li><p>用户通过浏览器发起请求，服务端收集数据。</p></li><li><p>将该数据插入mysql</p></li><li><p>判断是否执行成功，如果成功，则操作其他数据（可能还有其他的业务逻辑）。</p></li><li><p>如果执行失败，捕获唯一索引冲突异常，直接返回成功。</p></li></ol><h2 id="5、建防重表"><a class="header-anchor" href="#5、建防重表">¶</a>5、建防重表</h2><p>有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，直接在表中加唯一索引，显然是不太合适的。</p><p>针对这种情况，我们可以通过<code>建防重表</code>来解决问题。</p><p>该表可以只包含两个字段：<code>id</code> 和 <code>唯一索引</code>，唯一索引可以是多个字段比如：name、code等组合起来的唯一标识，例如：susan_0001。</p><p>具体流程图如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/8acdef56527f31d47eaa2741cb6c032d.png" alt="图片"></p><p>具体步骤：</p><ol><li><p>用户通过浏览器发起请求，服务端收集数据。</p></li><li><p>将该数据插入mysql防重表</p></li><li><p>判断是否执行成功，如果成功，则做mysql其他的数据操作（可能还有其他的业务逻辑）。</p></li><li><p>如果执行失败，捕获唯一索引冲突异常，直接返回成功。</p></li></ol><blockquote><p>需要特别注意的是：防重表和业务表必须在同一个数据库中，并且操作要在同一个事务中。</p></blockquote><h2 id="6、根据状态机"><a class="header-anchor" href="#6、根据状态机">¶</a>6、根据状态机</h2><p>很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态。如果这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性。</p><p>假如id=123的订单状态是<code>已支付</code>，现在要变成<code>完成</code>状态。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update &#96;order&#96; set status&#x3D;3 where id&#x3D;123 and status&#x3D;2;</span><br></pre></td></tr></table></figure><p>第一次请求时，该订单的状态是<code>已支付</code>，值是<code>2</code>，所以该<code>update</code>语句可以正常更新数据，sql执行结果的影响行数是<code>1</code>，订单状态变成了<code>3</code>。</p><p>后面有相同的请求过来，再执行相同的sql时，由于订单状态变成了<code>3</code>，再用<code>status=2</code>作为条件，无法查询出需要更新的数据，所以最终sql执行结果的影响行数是<code>0</code>，即不会真正的更新数据。但为了保证接口幂等性，影响行数是<code>0</code>时，接口也可以直接返回成功。</p><p>具体流程图如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/3d545175a9b4f58abcc3a12d5e310e9b.png" alt="图片"></p><p>具体步骤：</p><ol><li><p>用户通过浏览器发起请求，服务端收集数据。</p></li><li><p>根据id和当前状态作为条件，更新成下一个状态</p></li><li><p>判断操作影响行数，如果影响了1行，说明当前操作成功，可以进行其他数据操作。</p></li><li><p>如果影响了0行，说明是重复请求，直接返回成功。</p></li></ol><blockquote><p>主要特别注意的是，该方案仅限于要更新的<code>表有状态字段</code>，并且刚好要更新<code>状态字段</code>的这种特殊情况，并非所有场景都适用。</p></blockquote><h2 id="7、加分布式锁"><a class="header-anchor" href="#7、加分布式锁">¶</a>7、加分布式锁</h2><p>其实前面介绍过的<code>加唯一索引</code>或者<code>加防重表</code>，本质是使用了<code>数据库</code>的<code>分布式锁</code>，也属于分布式锁的一种。但由于<code>数据库分布式锁</code>的性能不太好，我们可以改用：<code>redis</code>或<code>zookeeper</code>。</p><p>鉴于现在很多公司分布式配置中心改用<code>apollo</code>或<code>nacos</code>，已经很少用<code>zookeeper</code>了，我们以<code>redis</code>为例介绍分布式锁。</p><p>目前主要有三种方式实现redis的分布式锁：</p><ol><li><p>setNx命令</p></li><li><p>set命令</p></li><li><p>Redission框架</p></li></ol><p>每种方案各有利弊，具体实现细节我就不说了，有兴趣的朋友可以加我微信找我私聊。</p><p>具体流程图如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/c27c7288f30cb160945a85c53446c94c.png" alt="图片"></p><p>具体步骤：</p><ol><li><p>用户通过浏览器发起请求，服务端会收集数据，并且生成订单号code作为唯一业务字段。</p></li><li><p>使用redis的set命令，将该订单code设置到redis中，同时设置超时时间。</p></li><li><p>判断是否设置成功，如果设置成功，说明是第一次请求，则进行数据操作。</p></li><li><p>如果设置失败，说明是重复请求，则直接返回成功。</p></li></ol><blockquote><p>需要特别注意的是：分布式锁一定要设置一个合理的过期时间，如果设置过短，无法有效的防止重复请求。如果设置过长，可能会浪费<code>redis</code>的存储空间，需要根据实际业务情况而定。</p></blockquote><h2 id="8、获取token"><a class="header-anchor" href="#8、获取token">¶</a>8、获取token</h2><p>除了上述方案之外，还有最后一种使用<code>token</code>的方案。该方案跟之前的所有方案都有点不一样，需要两次请求才能完成一次业务操作。</p><ol><li><p>第一次请求获取<code>token</code></p></li><li><p>第二次请求带着这个<code>token</code>，完成业务操作。</p></li></ol><p>具体流程图如下：</p><p>第一步，先获取token。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/f17e295a4527953ccb487ca2b0651a9d.png" alt="图片"></p><p>第二步，做具体业务操作。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/3cfc0dd93be88c99821181a47df2c63e.png" alt="图片"></p><p>具体步骤：</p><ol><li><p>用户访问页面时，浏览器自动发起获取token请求。</p></li><li><p>服务端生成token，保存到redis中，然后返回给浏览器。</p></li><li><p>用户通过浏览器发起请求时，携带该token。</p></li><li><p>在redis中查询该token是否存在，如果不存在，说明是第一次请求，做则后续的数据操作。</p></li><li><p>如果存在，说明是重复请求，则直接返回成功。</p></li><li><p>在redis中token会在过期时间之后，被自动删除。</p></li></ol><p>以上方案是针对幂等设计的。</p><p>如果是防重设计，流程图要改改：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/fc939c51e9ef8d555bc10483e157e38b.png" alt="图片"></p><blockquote><p>需要特别注意的是：token必须是全局唯一的。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好文章怕丢失?码起来!&lt;br&gt;
&lt;a&gt;本文转载自&lt;a href=&quot;https://blog.csdn.net/lisu061714112/article/details/115313913&quot;&gt;原文&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;高并发下如何保证接口的幂等性？&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="高并发" scheme="http://14uy2u.coding-pages.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="幂等性" scheme="http://14uy2u.coding-pages.com/tags/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>摊牌了！想做表情管理大师？</title>
    <link href="http://14uy2u.coding-pages.com/2021/04/15/%E5%85%B6%E5%AE%83/%E6%91%8A%E7%89%8C%E4%BA%86%EF%BC%81%E6%83%B3%E5%81%9A%E8%A1%A8%E6%83%85%E7%AE%A1%E7%90%86%E5%A4%A7%E5%B8%88%EF%BC%9F/"/>
    <id>http://14uy2u.coding-pages.com/2021/04/15/%E5%85%B6%E5%AE%83/%E6%91%8A%E7%89%8C%E4%BA%86%EF%BC%81%E6%83%B3%E5%81%9A%E8%A1%A8%E6%83%85%E7%AE%A1%E7%90%86%E5%A4%A7%E5%B8%88%EF%BC%9F/</id>
    <published>2021-04-15T11:55:23.000Z</published>
    <updated>2021-04-14T01:37:34.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="a-用法教程"><a class="header-anchor" href="#a-用法教程">¶</a><a>用法教程</a></h2><p><strong>用MarkDown也可以添加好玩的表情，用法<code>:对应单词描述:</code></strong><br>⚠️⚠️⚠️<u>如果看到你博客的<code>表情不生效</code>那么就要卸载<code>hexo-renderer-marked</code>插件依赖后，再安装新的<code>hexo-renderer-markdown-it</code>和<code>markdown-it-emoji</code>插件，然后再在<code>站点配置文件末尾添加</code>以下代码</u></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Markdown-it config</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span>  <span class="comment"># add emoji</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;v&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">¶</span></span><br></pre></td></tr></table></figure><h2 id="a-表情效果展示"><a class="header-anchor" href="#a-表情效果展示">¶</a><a>表情效果展示</a></h2><ul><li>数字系列：1️⃣   2️⃣ 3️⃣ 4️⃣</li><li>水果系列：🍎 🍐 🍉 🍊 🍌 🍋 🍑 🍓 🍇 🍍 🍒</li><li>动物系列：🐶 🐱 🐷 🐯 🐻 🐦 🦁 🦌 🐒 🐺 🐴 🐮 🐭 🐟 🐛 🕷</li><li>植物系列：🌹 🌿 🍄 🍅 🥔 🥕</li><li>球类：🏈 🏀 ⚾️</li><li>其它系列：🚲 👨 👩 ❤️ 😢 🔥 👦 👧 🐷 📱 ☎️ 🚗 ⛵️ 📖 📓 💻 👪 🏫 🏥 🔔 ⚠️ 🖊</li></ul><h2 id="a-表情对照单词如下"><a class="header-anchor" href="#a-表情对照单词如下">¶</a><a>表情对照单词如下</a></h2><ul><li>实力不允许我写出更多的单词😢</li></ul><blockquote><p>数字系列：“one”   “two” “three” “four”</p></blockquote><blockquote><p>水果系列：“apple” “pear” “watermelon” “orange” “banana” “lemon” “peach” “strawberry” “grapes” “pineapple” “cherries”</p></blockquote><blockquote><p>动物系列：“dog” “cat” “pig” “tiger” “bear” “bird” “lion” “deer” “monkey” “wolf” “horse” “cow” “mouse” “fish” “bug” “spider”</p></blockquote><blockquote><p>植物系列：“rose” “herb” “mushroom” “tomato” “potato” “carrot”</p></blockquote><blockquote><p>球类：“football” “basketball” “baseball”</p></blockquote><blockquote><p>其它系列：“bike” “man” “woman” “heart” “cry” “fire” “boy” “girl” “pig” “iphone” “phone” “car” “boat” “book” “notebook” “computer” “family” “school” “hospital” “bell” “warning” “pen”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;a-用法教程&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#a-用法教程&quot;&gt;¶&lt;/a&gt;&lt;a&gt;用法教程&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用MarkDown也可以添加好玩的表情，用法&lt;code&gt;:对应单词描述:&lt;/code&gt;&lt;/strong</summary>
      
    
    
    
    <category term="表情管理" scheme="http://14uy2u.coding-pages.com/categories/%E8%A1%A8%E6%83%85%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="emoji" scheme="http://14uy2u.coding-pages.com/tags/emoji/"/>
    
  </entry>
  
  <entry>
    <title>我试过的几种CORS跨域解决方法</title>
    <link href="http://14uy2u.coding-pages.com/2021/04/11/CORS%E8%B7%A8%E5%9F%9F/"/>
    <id>http://14uy2u.coding-pages.com/2021/04/11/CORS%E8%B7%A8%E5%9F%9F/</id>
    <published>2021-04-11T12:10:44.000Z</published>
    <updated>2021-04-23T06:49:52.648Z</updated>
    
    <content type="html"><![CDATA[<h1>URL的几个组成部分</h1><ul><li>url组成一般主要分为<code>协议</code>、<code>域名</code>、<code>端口</code>、<code>请求页面路径</code>、<code>参数</code>这几个部分</li></ul><h1>CORS是什么</h1><ul><li>CORS全称Cross-Origin Resource Sharing，意为跨域资源共享。</li></ul><h1>CORS有什么用(应用场景)</h1><p>跨域的作用是为了应用的数据安全考虑，不过又在某些时候，不得不开启跨域来达到我们的目的。</p><ul><li>当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问的那个资源就会遇到跨域问题。</li><li>举例子：<ul><li>1.在平时开发前后端分离项目中，前端vue项目的端口是8088，而后端项目是8080端口，虽然他们都是localhost主机下，但是端口不一样，前端请求后端接口时，如果后端接口没有设置允许跨域访问，就会访问失败</li><li>2.由于AJAX请求只能同源(协议、域名、端口三者都相同)使用的限制，所以前端使用了ajax请求而不设置允许跨域的，都会访问失败。 <img src= "/img/loading.gif" data-lazy-src="https://z3.ax1x.com/2021/04/12/cBUMwV.png" alt="后端没开跨域.png"></li></ul></li></ul><h1>CORS怎么用(解决办法)</h1><ul><li><h3 id="法1-配置类"><a class="header-anchor" href="#法1-配置类">¶</a>法1.配置类</h3><ul><li>创建CorsConfiguration实例，显式指定哪些请求可跨域</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 开启跨域</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mosey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/4/10 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CorsConfiguration <span class="title">buildConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认情况下，新创建的CorsConfiguration不允许任何跨域请求，并且必须显式配置以指示应允许的内容</span></span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式指定哪些请求允许跨域</span></span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        <span class="comment">//为指定的路径模式注册CorsConfiguration</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, buildConfig());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="法2-CrossOrigin注解"><a class="header-anchor" href="#法2-CrossOrigin注解">¶</a>法2.@CrossOrigin注解</h3><ul><li>查看@CrossOrigin源码得知， 该注解可用在类，接口，枚举和方法上 ，也可以类上和方法上结合一起使用。</li><li><code>@CrossOrigin</code>的属性有设置默认值，如果想用更加细的颗粒度来控制跨域，则看自己的业务需求，这里不多介绍。</li></ul></li><li><h3 id="法3-node-js配置文件开启"><a class="header-anchor" href="#法3-node-js配置文件开启">¶</a>法3.node.js配置文件开启</h3><ul><li>如果前端项目为NodeJs构建的项目，可在配置文件index.js中的代理中开启跨域<code>changeOriginL: true</code>(这样前端的localhost:8083请求传到后台会变成localhost:8080,达到同源)。<img src= "/img/loading.gif" data-lazy-src="https://z3.ax1x.com/2021/04/12/cDewSU.png" alt="cDewSU.png"></li></ul></li><li><h3 id="法4-jsonp（不建议"><a class="header-anchor" href="#法4-jsonp（不建议">¶</a>法4.jsonp（不建议)</h3><ul><li>将cors请求伪装成jsonp请求</li></ul></li></ul><blockquote><p>dataType:“jsonp”,<br>jsonp:“jsonpcallback”</p></blockquote><ul><li><h3 id="法5-nginx配置"><a class="header-anchor" href="#法5-nginx配置">¶</a>法5.nginx配置</h3></li></ul><p>具体请<a href="https://segmentfault.com/a/1190000011145364">参与</a></p><ul><li><h3 id="法6-springsecurity配置文件"><a class="header-anchor" href="#法6-springsecurity配置文件">¶</a>法6.springsecurity配置文件</h3><ul><li>如下图<img src= "/img/loading.gif" data-lazy-src="https://z3.ax1x.com/2021/04/12/cDKZjS.png" alt="cDKZjS.png"></li></ul></li></ul><h3 id="法7-H5新特性"><a class="header-anchor" href="#法7-H5新特性">¶</a>法7.H5新特性</h3><ul><li><code>window.postMessage(message,targetOrigin)</code>只能在两个客户端(可以不同源)的页面之间进行数据交换，<a>不能和服务端进行数据交换</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;URL的几个组成部分&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;url组成一般主要分为&lt;code&gt;协议&lt;/code&gt;、&lt;code&gt;域名&lt;/code&gt;、&lt;code&gt;端口&lt;/code&gt;、&lt;code&gt;请求页面路径&lt;/code&gt;、&lt;code&gt;参数&lt;/code&gt;这几个部分&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="跨域" scheme="http://14uy2u.coding-pages.com/categories/%E8%B7%A8%E5%9F%9F/"/>
    
    
    <category term="跨域" scheme="http://14uy2u.coding-pages.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB记录用户浏览商品记录</title>
    <link href="http://14uy2u.coding-pages.com/2021/03/27/%E6%95%B4%E5%90%88/Mongodb%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%95%86%E5%93%81%E8%AE%B0%E5%BD%95/"/>
    <id>http://14uy2u.coding-pages.com/2021/03/27/%E6%95%B4%E5%90%88/Mongodb%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%95%86%E5%93%81%E8%AE%B0%E5%BD%95/</id>
    <published>2021-03-27T07:25:45.000Z</published>
    <updated>2021-04-23T06:19:54.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB是什么"><a class="header-anchor" href="#MongoDB是什么">¶</a>MongoDB是什么</h2><ul><li>基于分布式文件存储的一种数据库</li><li>MongoDB中的记录是一个文档，它是由字段和值对组成的数据结构。MongoDB文档类似于JSON对象。字段的值可以包括其他文档，数组和文档数组。<img src= "/img/loading.gif" data-lazy-src="https://z3.ax1x.com/2021/03/26/6jPs76.png" alt="6jPs76.png"></li><li>和mysql对比理解</li></ul><table><thead><tr><th style="text-align:left">MongoDB</th><th style="text-align:left">Mysql</th></tr></thead><tbody><tr><td style="text-align:left">DB</td><td style="text-align:left">库</td></tr><tr><td style="text-align:left">collection集合</td><td style="text-align:left">表</td></tr><tr><td style="text-align:left">Document    (Json)</td><td style="text-align:left">行</td></tr><tr><td style="text-align:left">fild(Json中的key)</td><td style="text-align:left">字段</td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">索引</td></tr></tbody></table><ul><li></li></ul><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">String</td><td style="text-align:left">常用类型。在 MongoDB 中，合法编码是UTF-8</td></tr><tr><td style="text-align:left">Integer</td><td style="text-align:left">由服务器决定是32 位还是64 位</td></tr><tr><td style="text-align:left">Boolean</td><td style="text-align:left">布尔值</td></tr><tr><td style="text-align:left">Double</td><td style="text-align:left">双精度浮点值。</td></tr><tr><td style="text-align:left">Min/Max keys</td><td style="text-align:left">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td></tr><tr><td style="text-align:left">Array</td><td style="text-align:left">用于将数组或列表或多个值存储为一个键。</td></tr><tr><td style="text-align:left">Timestamp</td><td style="text-align:left">保存文档修改或添加的时间。</td></tr><tr><td style="text-align:left">Object</td><td style="text-align:left">用于内嵌文档。</td></tr><tr><td style="text-align:left">Null</td><td style="text-align:left">用于创建空值。</td></tr><tr><td style="text-align:left">Symbol</td><td style="text-align:left">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">保存当前日期或时间。也可自定义 Date 对象。</td></tr><tr><td style="text-align:left">Object ID</td><td style="text-align:left">对象 ID。用于创建文档的 ID。</td></tr><tr><td style="text-align:left">Binary Data</td><td style="text-align:left">存储二进制数据。</td></tr><tr><td style="text-align:left">Code</td><td style="text-align:left">用于在文档中存储 Js 代码。</td></tr><tr><td style="text-align:left">Regular expression</td><td style="text-align:left">正则表达式</td></tr></tbody></table><h2 id="MongoDB的一些优点"><a class="header-anchor" href="#MongoDB的一些优点">¶</a>MongoDB的一些优点</h2><ul><li><font color="red">复制高可用性(主从复制，主机读写，从机只读)</font>，把数据同步复制到多个服务器中。</li><li><font color="red">分片技术</font>，由于一台服务器不能存储海量数据，所以要把大数据分割开来，然后把分片分布存储在各个服务器中，达到<font color="red">高吞吐量</font></li><li>MongoDB还提供专门的<font color="red">性能监控</font>功能。</li><li>MongoDB 的文档数据模型和索引系统能有效提升数据库性能；复制集功能提供数据冗余，自动化容灾容错，提升数据库可用性；分片技术能够分散单服务器的读写压力，提高并发能力，提升数据库的可拓展性。</li></ul><h2 id="MongoDB应用场景"><a class="header-anchor" href="#MongoDB应用场景">¶</a>MongoDB应用场景</h2><ul><li>Mongo非常适合<font color="red">实时</font>的插入，更新与查询，并具备网站<font color="red">实时</font>数据存储所需的复制及高度伸缩性</li><li><font color="red">地理位置信息存储</font>，通过2d和2dsphere索引，可以方便的查询出具体的位置信息</li><li><font color="red">聚合操作</font>处理数据(如统计平均值，求和等)，并返回计算结果</li></ul><h2 id="MongoDB安装配置和启动-windows下"><a class="header-anchor" href="#MongoDB安装配置和启动-windows下">¶</a>MongoDB安装配置和启动(windows下)</h2><ul><li>1、<a href="https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-3.2.21-signed.msi">Mongodb安装包下载</a></li><li>2、下载完安装时有一个“complete”和“custom”选项。 因complete不能选择安装位置，所以我们选择custom安装。</li><li>3、在安装根目录下新建data文件夹，data文件夹下再新建一个db和log文件夹。</li><li>4、同样在根目录下新建配置文件mongod.cfg，内容如下(<font color="red">注意替换成自己的路径</font>)</li></ul><blockquote><p>systemLog:<br>destination: file<br>path: D:\Mongodb\data\log\mongod.log<br>storage:<br>dbPath: D:\Mongodb\data\db</p></blockquote><ul><li>5、右键“以管理员身份运行”cmd，输入下面命令，把MongoDB安装为服务(<font color="red">注意自行替换路径</font>)</li></ul><blockquote><p>D:\Mongodb\bin\mongod.exe --config “D:\Mongodb\mongod.cfg” --install</p></blockquote><ul><li>6、运行net start MongoDB启动服务，其它相关服务命令如下(<font color="red">注意自行替换路径</font>)</li></ul><blockquote><p>启动服务：net start MongoDB<br>关闭服务：net stop MongoDB<br>移除服务：D:\Mongodb\bin\mongod.exe --remove</p></blockquote><ul><li>7、下载免费的<a href="https://robomongo.org/download">robo3t</a>客户端，解压到文件夹，打开robo3t.exe并连接到localhost:27017。</li></ul><h2 id="SpringBoot整合MongoDB"><a class="header-anchor" href="#SpringBoot整合MongoDB">¶</a>SpringBoot整合MongoDB</h2><ul><li>环境准备</li></ul><blockquote><p>springboot 2.1.3<br>jdk 1.8<br>maven 3.6<br>MongoDB 3.2.21<br>Robo 3T 1.4</p></blockquote><ul><li>1、添加spring整合mongodb的依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2、配置文件spring.data节点下增加mongodb节点</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mongodb:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># ip</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27017</span> <span class="comment"># 端口</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">mall-port</span> <span class="comment"># 库名</span></span><br></pre></td></tr></table></figure><ul><li>3、增加商品浏览记录实体类文档<ul><li>经测试，字段前加不加@Indexed注解的时候，接口中的findBy…衍生查询都是可以执行，不过查询速度没有加索引的时候快。</li><li>实体类可以不用与项目mysql中的表对应，因为这个文档数据是存储在MongoDB中的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Document</span> <span class="comment">//代表MongoDB的集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberReadHistory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span>  <span class="comment">//MongoDB默认的_id主键</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@Indexed</span></span><br><span class="line">  <span class="keyword">private</span> Long memberId;</span><br><span class="line">    <span class="keyword">private</span> String memberNickname;</span><br><span class="line">    <span class="keyword">private</span> String memberIcon;</span><br><span class="line">    <span class="meta">@Indexed</span></span><br><span class="line">  <span class="keyword">private</span> Long productId;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> String productPic;</span><br><span class="line">    <span class="keyword">private</span> String productSubTitle;</span><br><span class="line">    <span class="keyword">private</span> String productPrice;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    ...get/set方法</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>4、编写MemberReadHistoryRepository接口继承MongoRepository&lt;T,ID&gt;，可根据规则定义衍生方法，还可以调用CrudRepository&lt;T, ID&gt;接口中封装好的CRUD接口。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberReadHistoryRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">MemberReadHistory</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据会员id按时间倒序获取浏览记录</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> memberId 会员id</span></span><br><span class="line"><span class="comment"> */</span>  <span class="function">List&lt;MemberReadHistory&gt; <span class="title">findByMemberIdOrderByCreateTimeDesc</span><span class="params">(Long memberId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;MemberReadHistory&gt; <span class="title">findByProductName</span><span class="params">(String pName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>5、编写Service层接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberReadHistoryService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成浏览记录(插入MongoDB数据库)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(MemberReadHistory memberReadHistory)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量删除浏览记录</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(List&lt;String&gt; ids)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取用户浏览历史记录</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">List&lt;MemberReadHistory&gt; <span class="title">list</span><span class="params">(Long memberId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6、Service层实现类Impl(写业务逻辑)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberReadHistoryServiceImpl</span> <span class="keyword">implements</span> <span class="title">MemberReadHistoryService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> MemberReadHistoryRepository memberReadHistoryRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(MemberReadHistory memberReadHistory)</span> </span>&#123;</span><br><span class="line">        memberReadHistory.setId(<span class="keyword">null</span>);</span><br><span class="line">        memberReadHistory.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        memberReadHistoryRepository.save(memberReadHistory);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        List&lt;MemberReadHistory&gt; deleteList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String id:ids)&#123;</span><br><span class="line">            MemberReadHistory memberReadHistory = <span class="keyword">new</span> MemberReadHistory();</span><br><span class="line">            memberReadHistory.setId(id);</span><br><span class="line">            deleteList.add(memberReadHistory);</span><br><span class="line">        &#125;</span><br><span class="line">        memberReadHistoryRepository.deleteAll(deleteList);</span><br><span class="line">        <span class="keyword">return</span> ids.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;MemberReadHistory&gt; <span class="title">list</span><span class="params">(Long memberId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memberReadHistoryRepository.findByMemberIdOrderByCreateTimeDesc(memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>7、Controller视图层</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="meta">@Api(tags = &quot;MemberReadHistoryController&quot;, description = &quot;会员商品浏览记录管理&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/member/readHistory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberReadHistoryController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> MemberReadHistoryService memberReadHistoryService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> MemberReadHistoryRepository readHistoryRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;创建浏览记录&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/create&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span> MemberReadHistory memberReadHistory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = memberReadHistoryService.create(memberReadHistory);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.success(count);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;删除浏览记录&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/delete&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CommonResult <span class="title">delete</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = memberReadHistoryService.delete(ids);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.success(count);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;展示浏览记录&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> CommonResult&lt;List&lt;MemberReadHistory&gt;&gt; list(Long memberId) &#123;</span><br><span class="line">        List&lt;MemberReadHistory&gt; memberReadHistoryList = memberReadHistoryService.list(memberId);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(memberReadHistoryList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>8、测试</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MongoDB是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MongoDB是什么&quot;&gt;¶&lt;/a&gt;MongoDB是什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基于分布式文件存储的一种数据库&lt;/li&gt;
&lt;li&gt;MongoDB中的记录是一个文档，它是由字</summary>
      
    
    
    
    <category term="数据库" scheme="http://14uy2u.coding-pages.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MongoDB" scheme="http://14uy2u.coding-pages.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合ElastitcSearch中文分词</title>
    <link href="http://14uy2u.coding-pages.com/2021/03/14/es/SpringBoot%E6%95%B4%E5%90%88ElastitcSearch%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"/>
    <id>http://14uy2u.coding-pages.com/2021/03/14/es/SpringBoot%E6%95%B4%E5%90%88ElastitcSearch%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/</id>
    <published>2021-03-14T12:57:15.000Z</published>
    <updated>2021-04-23T06:16:39.713Z</updated>
    
    <content type="html"><![CDATA[<h1>ElasticSearch</h1><blockquote><p>Elasticsearch是一个基于Lucene的搜索服务器。<br>它提供了一个<font color="red">分布式</font>多用户能力的全文搜索引擎，基于RESTful web接口，是一个流行的<font color="red">企业级搜索引擎</font>。<br>能够达到<font color="red">实时搜索</font>，稳定，可靠，快速，安装使用方便，也能<font color="red">实时统计</font>数据。<br>通过HTTP使用JSON进行数据索引</p></blockquote><h2 id="ElasticSearch的安装"><a class="header-anchor" href="#ElasticSearch的安装">¶</a>ElasticSearch的安装</h2><p>ps:<font color="red">ElasticSearch6.22需要jdk1.8版本以上，否则安装会报错</font><br>1、<a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-2-2">下载</a>Elasticsearch6.2.2的zip包，并解压到任一自定义空目录。<br>2、由于要进行中文分词的需要。我们要安装一个分词插件。在elasticsearch-6.2.2\bin目录下执行以下命令：elasticsearch-plugin install <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip</a><br>3、到bin目录下双击elasticsearch.bat启动Elasticsearch服务(先不要关闭)<br>4、<a href="https://artifacts.elastic.co/downloads/kibana/kibana-6.2.2-windows-x86_64.zip">下载</a>Kibana分词客户端，版本和elasticsearch对应，安装目录自动选择一个空目录即可<br>5、到bin目录下双击kibana.bat，启动Kibana<br>6、访问<a href="http://localhost:5601/">http://localhost:5601</a>。在Kibana界面上的Dev Tools菜单里边练习DSL语句。教程<a href="https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&amp;mid=2247484699&amp;idx=1&amp;sn=5367206c3c3da2278821dd9fad648850&amp;scene=21#wechat_redirect">直接从“数据准备开始练手”</a>。</p><h2 id="ElasticSearch和MySql对比记忆"><a class="header-anchor" href="#ElasticSearch和MySql对比记忆">¶</a>ElasticSearch和MySql对比记忆</h2><table><thead><tr><th style="text-align:left">ElasticSearch</th><th style="text-align:left">Mysql</th></tr></thead><tbody><tr><td style="text-align:left"><font color="red">Index<font></font></font></td><td style="text-align:left">库</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:left">表</td></tr><tr><td style="text-align:left">Document</td><td style="text-align:left">行</td></tr><tr><td style="text-align:left">Fileds</td><td style="text-align:left">字段</td></tr><tr><td style="text-align:left">全文都可索引</td><td style="text-align:left"><font color="bule">Index<font></font></font></td></tr><tr><td style="text-align:left">SQL</td><td style="text-align:left">DSL</td></tr></tbody></table><p>Ps:注意区分两个Index分别的意思</p><ul><li>Cluster集群：多个elasticsearch服务的集合就是集群。目的是防止某台服务器发生事故，导致系统不能正常运行，从而让服务器达到一个稳定、高效的状态。</li><li>Node节点：一个节点可代表一个独立服务器。</li><li>Shard分片：为了缓解内存压力，把数据分布在多个节点中。</li><li>Replia副本：为提高查询吞吐量或实现高可用性，可以使用分片副本，副本<br>下面是一段es查询结果返回截图<br><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/03/15/6Dy1w8.png" alt="es数据"></li></ul><h2 id="SpringBoot整合ElasticSearch搜索"><a class="header-anchor" href="#SpringBoot整合ElasticSearch搜索">¶</a>SpringBoot整合ElasticSearch搜索</h2><blockquote><p>版本：SpringBoot 2.1.3、JDK8、ElasticSearch 6.22、Maven 3.6<br>参考<a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=%25e9%25a1%25b9%25e7%259b%25ae%25e4%25bd%25bf%25e7%2594%25a8%25e6%25a1%2586%25e6%259e%25b6%25e4%25bb%258b%25e7%25bb%258d">mall</a>，很好的一个开源项目，教程详细，极力推荐。<br>下面用到的EsProduct实体类就是根据mall项目中对应的数据库表编写的。</p></blockquote><h3 id="1、添加依赖"><a class="header-anchor" href="#1、添加依赖">¶</a>1、添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、修改项目配置文件"><a class="header-anchor" href="#2、修改项目配置文件">¶</a>2、修改项目配置文件</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">repositories:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span> <span class="comment"># 本机Es地址和端口号</span></span><br><span class="line">    <span class="attr">cluster-name:</span> <span class="string">elasticsearch</span> <span class="comment"># es集群</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、给ES增加操作文档EsProduct实体类，其中要用到几个重要的注解"><a class="header-anchor" href="#3、给ES增加操作文档EsProduct实体类，其中要用到几个重要的注解">¶</a>3、给ES增加操作文档EsProduct实体类，其中要用到几个重要的注解</h3><ul><li>不需要中文分词的字段设置成@Field(type = FieldType.Keyword)类型，需要中文分词的设置成@Field(analyzer = “ik_max_word”,type = FieldType.Text)类型。</li><li>shards代表分片，replicas副本备份，防止宕机数据丢失。</li><li>type = FieldType.Nested代表嵌套对象类型，比如用于保存文章评论相关信息(评论数，评论用户，评论内容等等)，不懂可以看这篇<a href="https://blog.csdn.net/laoyang360/article/details/82950393">博客</a></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Document(indexName = &quot;pms&quot;, type = &quot;product&quot;,shards = 1,replicas = 0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsProduct</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//表示是文档的id，文档可以认为是mysql中表行的概念</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//type = FieldType.Keyword代表不会进行分词建立索引的类型</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String productSn;</span><br><span class="line">    <span class="keyword">private</span> Long brandId;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String brandName;</span><br><span class="line">    <span class="keyword">private</span> Long productCategoryId;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String productCategoryName;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="comment">//analyzer = &quot;ik_max_word&quot;,type = FieldType.Text代表会进行分词操作</span></span><br><span class="line">    <span class="meta">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String subTitle;</span><br><span class="line">    <span class="meta">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String keywords;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="keyword">private</span> Integer sale;</span><br><span class="line">    <span class="keyword">private</span> Integer newStatus;</span><br><span class="line">    <span class="keyword">private</span> Integer recommandStatus;</span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="keyword">private</span> Integer promotionType;</span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line"><span class="comment">//  type =FieldType.Nested代表嵌套对象类型</span></span><br><span class="line">    <span class="meta">@Field(type =FieldType.Nested)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;EsProductAttributeValue&gt; attrValueList;</span><br><span class="line">    <span class="comment">//...省略get、set</span></span><br></pre></td></tr></table></figure><h3 id="4、添加继承ElasticsearchRepository-T-ID-类的接口EsProductRepository"><a class="header-anchor" href="#4、添加继承ElasticsearchRepository-T-ID-类的接口EsProductRepository">¶</a>4、添加继承ElasticsearchRepository&lt;T,ID&gt;类的接口EsProductRepository</h3><ul><li>EsProductRepository继承了ElasticsearchRepository&lt;T,ID&gt;接口,ID理解为实体类ID的主键，可自定义一个查询(衍生查询)，格式findBy…，可根据命名来自动识别你要查询哪些字段，而不用写实现类。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> */ <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EsProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">EsProduct</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索查询</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 商品名称</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> subTitle 商品标题</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keywords 商品关键字</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> page 分页信息</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">Page&lt;EsProduct&gt; <span class="title">findByNameOrSubTitleOrKeywords</span><span class="params">(String name, String subTitle, String keywords, Pageable page)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、添加Service层接口EsProductService"><a class="header-anchor" href="#5、添加Service层接口EsProductService">¶</a>5、添加Service层接口EsProductService</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EsProductService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中导入所有商品到ES</span></span><br><span class="line"><span class="comment"> */</span>  <span class="function"><span class="keyword">int</span> <span class="title">importAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id删除商品</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id创建商品</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">EsProduct <span class="title">create</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量删除商品</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(List&lt;Long&gt; ids)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据关键字搜索名称或者副标题</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">Page&lt;EsProduct&gt; <span class="title">search</span><span class="params">(String keyword, Integer pageNum, Integer pageSize)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、添加EsProductService接口的实现类EsProductServiceImpl"><a class="header-anchor" href="#6、添加EsProductService接口的实现类EsProductServiceImpl">¶</a>6、添加EsProductService接口的实现类EsProductServiceImpl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsProductServiceImpl</span> <span class="keyword">implements</span> <span class="title">EsProductService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(EsProductServiceImpl.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> EsProductDao productDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> EsProductRepository productRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">importAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;EsProduct&gt; esProductList = productDao.getAllEsProductList(<span class="keyword">null</span>);</span><br><span class="line">        Iterable&lt;EsProduct&gt; esProductIterable = productRepository.saveAll(esProductList);</span><br><span class="line">        Iterator&lt;EsProduct&gt; iterator = esProductIterable.iterator();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        productRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> EsProduct <span class="title">create</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        EsProduct result = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;EsProduct&gt; esProductList = productDao.getAllEsProductList(id);</span><br><span class="line">        <span class="keyword">if</span> (esProductList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            EsProduct esProduct = esProductList.get(<span class="number">0</span>);</span><br><span class="line">            result = productRepository.save(esProduct);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(List&lt;Long&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(ids)) &#123;</span><br><span class="line">            List&lt;EsProduct&gt; esProductList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Long id : ids) &#123;</span><br><span class="line">                EsProduct esProduct = <span class="keyword">new</span> EsProduct();</span><br><span class="line">                esProduct.setId(id);</span><br><span class="line">                esProductList.add(esProduct);</span><br><span class="line">            &#125;</span><br><span class="line">            productRepository.deleteAll(esProductList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Page&lt;EsProduct&gt; <span class="title">search</span><span class="params">(String keyword, Integer pageNum, Integer pageSize)</span> </span>&#123;</span><br><span class="line">        Pageable pageable = PageRequest.of(pageNum, pageSize);</span><br><span class="line">        <span class="keyword">return</span> productRepository.findByNameOrSubTitleOrKeywords(keyword, keyword, keyword, pageable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、Controller层CRUD方法"><a class="header-anchor" href="#7、Controller层CRUD方法">¶</a>7、Controller层CRUD方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="meta">@Api(tags = &quot;EsProductController&quot;, description = &quot;搜索商品管理&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/esProduct&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsProductController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> EsProductService esProductService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;导入所有数据库中商品到ES&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/importAll&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CommonResult&lt;Integer&gt; <span class="title">importAllList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = esProductService.importAll();</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;根据id删除商品&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/delete/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CommonResult&lt;Object&gt; <span class="title">delete</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        esProductService.delete(id);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;根据id批量删除商品&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/delete/batch&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CommonResult&lt;Object&gt; <span class="title">delete</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span> </span>&#123;</span><br><span class="line">        esProductService.delete(ids);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;根据id创建商品&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/create/&#123;id&#125;&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CommonResult&lt;EsProduct&gt; <span class="title">create</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        EsProduct esProduct = esProductService.create(id);</span><br><span class="line">        <span class="keyword">if</span> (esProduct != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.success(esProduct);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;简单搜索&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/search/simple&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> CommonResult&lt;CommonPage&lt;EsProduct&gt;&gt; search(<span class="meta">@RequestParam(required = false)</span> String keyword,</span><br><span class="line">                                                      <span class="meta">@RequestParam(required = false, defaultValue = &quot;0&quot;)</span> Integer pageNum,</span><br><span class="line">                                                      <span class="meta">@RequestParam(required = false, defaultValue = &quot;5&quot;)</span> Integer pageSize) &#123;</span><br><span class="line">        Page&lt;EsProduct&gt; esProductPage = esProductService.search(keyword, pageNum, pageSize);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(CommonPage.restPage(esProductPage));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、测试"><a class="header-anchor" href="#7、测试">¶</a>7、测试</h3><ul><li>刚开始ES中是没有数据的，所以我们调importAllList接口导入数据，会得到下图的pms索引<img src= "/img/loading.gif" data-lazy-src="https://z3.ax1x.com/2021/03/23/6TLfqx.png" alt="pms.png"></li><li>search接口最终会调用实现类中的衍生方法findByNameOrSubTitleOrKeywords，根据name或者subtitle或者keywords来分词，得到下图<br><font color="red">subTitle字段</font><br><img src= "/img/loading.gif" data-lazy-src="https://z3.ax1x.com/2021/03/25/6OBkmd.png" alt="subTitle字段.png"><br><font color="red">name字段</font><br><img src= "/img/loading.gif" data-lazy-src="https://z3.ax1x.com/2021/03/25/6OB1mj.png" alt="name.png"></li></ul><h3 id="如要扩展分词字段"><a class="header-anchor" href="#如要扩展分词字段">¶</a>如要扩展分词字段</h3><ol><li></li></ol><blockquote><p>在EsProduct类的字段中添加@Field(analyzer = “ik_max_word”,type = FieldType.Text)注解分词</p></blockquote><ol start="2"><li></li></ol><blockquote><p>在继承ElasticsearchRepository类的接口中的衍生方法findByNameOrSubTitleOrKeywords按照规则自行拼接字段，注意==参数互相对应，和实体类中的字段名保持一致(大小写)==</p></blockquote><ol start="3"><li></li></ol><blockquote><p>先删除原来的索引pms再启动，不然会报错，启动完成后再重新运行importAll方法重新导入数据到Es中去。</p></blockquote><ol start="4"><li></li></ol><blockquote><p>自行完成测试新加的分词字段</p></blockquote><h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3><ul><li><a href="https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-06">地址在这</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;ElasticSearch&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Elasticsearch是一个基于Lucene的搜索服务器。&lt;br&gt;
它提供了一个&lt;font color=&quot;red&quot;&gt;分布式&lt;/font&gt;多用户能力的全文搜索引擎，基于RESTful web接口，是一</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://14uy2u.coding-pages.com/categories/SpringBoot/"/>
    
    
    <category term="ElasticSearch" scheme="http://14uy2u.coding-pages.com/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Redis(其实不难)</title>
    <link href="http://14uy2u.coding-pages.com/2021/03/07/%E6%95%B4%E5%90%88/SpringBoot%E6%95%B4%E5%90%88redis/"/>
    <id>http://14uy2u.coding-pages.com/2021/03/07/%E6%95%B4%E5%90%88/SpringBoot%E6%95%B4%E5%90%88redis/</id>
    <published>2021-03-07T09:05:18.000Z</published>
    <updated>2021-05-22T03:26:07.745Z</updated>
    
    <content type="html"><![CDATA[<h1>两种整合方法</h1><blockquote><p>一种是spring-boot-starter-data-redis<br>另一种是jedis</p></blockquote><h2 id="方法一"><a class="header-anchor" href="#方法一">¶</a>方法一</h2><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖配置--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、SpringBoot配置文件定义redis相关</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># Redis主机地址</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># Redis数据库下标（从0开始，默认第一个库）</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment"># Redis端口</span></span><br><span class="line">    <span class="attr">password:</span> <span class="comment"># Redis密码（默认为空）</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span> <span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line">        <span class="attr">timeout:</span> <span class="string">3000ms</span> <span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="comment"># 自定义redis的key的前缀和到期时间</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">key:</span></span><br><span class="line">    <span class="attr">prefix:</span></span><br><span class="line">      <span class="attr">authCode:</span> <span class="string">&quot;portal:authCode:&quot;</span></span><br><span class="line">    <span class="attr">expire:</span></span><br><span class="line">      <span class="attr">authCode:</span> <span class="number">120</span> <span class="comment"># 验证码超期时间</span></span><br></pre></td></tr></table></figure><p>3、定义一个redis的常用操作接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">String <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置超期时间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> expire)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自增操作</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> delta 自增步长</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">Long <span class="title">increment</span><span class="params">(String key, <span class="keyword">long</span> delta)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、创建RedisService接口的实现类RedisServiceImpl，并在实现类中导入第一步依赖中的StringRedisTemplate类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisServiceImpl</span> <span class="keyword">implements</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.expire(key, expire, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">increment</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().increment(key,delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RedisTemplate的以字符串为中心的扩展。 由于大多数针对Redis的操作都是基于String的，因此此类提供了一个专用类，该类可最大程度地减少其通用template配置，尤其是在序列化程序方面。</p></blockquote><p>5、使用方法<br>1.在要使用的类中，注入接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> RedisService redisService;</span><br></pre></td></tr></table></figure><p>2.get set expire使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出配置文件中自定义的key的前缀和到期时间</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;redis.key.prefix.authCode&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String REDIS_KEY_PREFIX_AUTH_CODE;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;redis.key.expire.authCode&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Long AUTH_CODE_EXPIRE_SECONDS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置值</span></span><br><span class="line"> redisService.set(REDIS_KEY_PREFIX_AUTH_CODE+<span class="string">&quot;任一字符串&quot;</span>,value)  </span><br><span class="line"> <span class="comment">//获取值  </span></span><br><span class="line"> redisService.get(key)  </span><br><span class="line"> <span class="comment">//设置到期时间expirationdate</span></span><br><span class="line"> redisService.expire(key,AUTH_CODE_EXPIRE_SECONDS) </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="方法二"><a class="header-anchor" href="#方法二">¶</a>方法二</h2><blockquote><p>配置文件和上面的一样，只是依赖和工具类不一样。个人觉得这种方法好点。这个能操作除了String类型外，还可以操作其它类型的数据。</p></blockquote><p>1.添加jedis依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.JedisUtil工具类编写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redis_host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer redis_port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.jedis.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer max_idle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.jedis.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer min_idle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取redis操作对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String host = redis_host;</span><br><span class="line">        <span class="keyword">int</span> port = redis_port;</span><br><span class="line">        <span class="keyword">int</span> maxTotal = max_idle;</span><br><span class="line">        <span class="keyword">int</span> maxIdle = min_idle;</span><br><span class="line">        <span class="comment">//设置配置信息</span></span><br><span class="line">  JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxIdle(maxIdle);</span><br><span class="line">        jedisPoolConfig.setMaxTotal(maxTotal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">  JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, host, port);</span><br><span class="line">        Jedis jedis=jedisPool.getResource();</span><br><span class="line">        <span class="keyword">return</span> jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注入工具类</span></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> JedisUtil jedisUtil;</span><br><span class="line"></span><br><span class="line">省略...</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取jedis对象，操作String类型，其它类型的省略。</span></span><br><span class="line">Jedis jedis = jedisUtil.getJedis();</span><br><span class="line">jedis.set(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;两种整合方法&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一种是spring-boot-starter-data-redis&lt;br&gt;
另一种是jedis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;方法一&quot;&gt;&lt;a class=&quot;header-anchor&quot; href</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://14uy2u.coding-pages.com/categories/SpringBoot/"/>
    
    
    <category term="redis" scheme="http://14uy2u.coding-pages.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring实现Aop切面编程(日志记录)</title>
    <link href="http://14uy2u.coding-pages.com/2021/03/07/%E6%95%B4%E5%90%88/spring%E5%AE%9E%E7%8E%B0%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <id>http://14uy2u.coding-pages.com/2021/03/07/%E6%95%B4%E5%90%88/spring%E5%AE%9E%E7%8E%B0%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</id>
    <published>2021-03-07T02:05:18.000Z</published>
    <updated>2021-05-22T03:31:39.859Z</updated>
    
    <content type="html"><![CDATA[<h1>Spring两大特性</h1><ul><li>IOC(控制反转)</li></ul><blockquote><p>IOC：通俗点来讲，就是把对象的创建交给Spring容器来管理，不用我们手动new</p></blockquote><ul><li>AOP(面向切面编程)</li></ul><blockquote><p>AOP：定义一个切面，在切面中执行特定代码，实现代码增强，常用于日志打印，异常处理，性能耗时计算，事务处理，安全验证等等，</p></blockquote><h1>用AOP和不用AOP做日志记录的区别</h1><ul><li>不用AOP:</li></ul><blockquote><p>每个方法都要写记录日志的代码，代码多，工作量大</p></blockquote><ul><li>使用AOP:</li></ul><blockquote><p>日志统一交给某个类(切面配置类)来记录，这样做的好处是业务代码简洁了，也能达到一定的解耦等等</p></blockquote><h1>AOP实战之旅(基于注解)</h1><ul><li>实战环境：jdk8、SpringBoot2.4.3、maven3.6。</li><li>@Pointcut:</li><li>@Before: 切面方法执行之前执行</li><li>@After: 切面方法执行之后执行 。</li><li>@AfterRunning: 切面方法成功返回结果之后执行</li><li>@AfterThrowing: 切面方法抛出异常后执行</li></ul><h2 id="1、SpringBoot项目搭建，并-font-color-red-加入AOP依赖-font"><a class="header-anchor" href="#1、SpringBoot项目搭建，并-font-color-red-加入AOP依赖-font">¶</a>1、SpringBoot项目搭建，并<font color="red"><strong>加入AOP依赖</strong></font></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、创建切面类SystemLogAspect"><a class="header-anchor" href="#2、创建切面类SystemLogAspect">¶</a>2、创建切面类SystemLogAspect</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//标识为一个切面类</span></span><br><span class="line"><span class="meta">@Component</span>   <span class="comment">//交给Spring管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Pointcut(&quot;@annotation(com.demo.aop.joggle.SystemLogInterface)&quot;)  //应用在有@SystemLogInterface注解的方法上</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controllerAspect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;我是切点&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(&quot;controllerAspect()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程绑定变量（该数据只有当前请求的线程可见）</span></span><br><span class="line">    Date beginTime = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(<span class="string">&quot;方法执行前通知&quot;</span>);</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterReturning(&quot;controllerAspect()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;方法返回结果后执行&quot;</span>);</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterThrowing(&quot;controllerAspect()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;方法发生异常后执行&quot;</span>);</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、创建自定义注解SystemLogInterface"><a class="header-anchor" href="#3、创建自定义注解SystemLogInterface">¶</a>3、创建自定义注解SystemLogInterface</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:切面注解</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span>: Mosey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/3/6 14:50</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//作用于参数或方法上 </span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SystemLogInterface &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、创建TestController，并在test方法处使用自定义的SystemLogInterface注解"><a class="header-anchor" href="#4、创建TestController，并在test方法处使用自定义的SystemLogInterface注解">¶</a>4、创建TestController，并在test方法处使用自定义的SystemLogInterface注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span> </span><br><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SystemLogInterface</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/aop&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">      System.out.println(<span class="string">&quot;方法正在执行中。。。&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;访问成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、运行项目。访问localhost-8080-test-aop会打印出下面的结果"><a class="header-anchor" href="#5、运行项目。访问localhost-8080-test-aop会打印出下面的结果">¶</a>5、运行项目。访问localhost:8080/test/aop会打印出下面的结果</h2><blockquote><p>方法执行前通知<br>方法正在执行中。。。<br>方法返回结果后执行</p></blockquote><p>ＰＳ：如果方法运行时发生异常，会进入到@AfterThrowing中，如果我们有在test()方法中捕获异常，则不会进入@AfterThrowing。</p><h1>AOP实战之旅(不基于注解)</h1><ul><li>上面的切面类SystemLogAspect的切点用到的是@Pointcut(“@annotation(com.demo.aop.joggle.SystemLogInterface)”)基于注解实现AOP的。</li><li>其实我们也可以用@Pointcut(“execution(* com.demo.aop.controller…test())”)来进行切点。</li><li>execution(* com.demo.aop.controller…test())意思是：com.demo.aop.controller包下的所有类的test方法(),括号里边的…表示任何参数。</li><li>PS:切点换成execution表达式后，要把controller层的@SystemLogInterface注解注释掉。</li><li>运行结果和上面的一样</li></ul><blockquote><p>方法执行前通知<br>方法正在执行中。。。<br>方法返回结果后执行</p></blockquote><h2 id="execution表达式"><a class="header-anchor" href="#execution表达式">¶</a>execution表达式</h2><p>更多有关于execution表达式的，可以看下面的截图，execution也可以用连接符&amp;&amp; || 和!等匹配多个表达式，具体问题具体分析<br><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/03/09/617yvT.png" alt="execution表达式.png"></p><h2 id="补充"><a class="header-anchor" href="#补充">¶</a>补充</h2><ul><li>1.当<code>@Before</code>、<code>@After</code>、<code>@Around</code>、<code>@AfterReturning</code>、<code>@AfterThrowing</code>同时使用并切点相同时<ul><li><code>@Around</code>中没有调用<code>pjp.proceed()</code>方法时,不执行切点对应的目标方法</li><li>如果有调用<code>pjp.proceed()</code>方法时，开始执行切点对应的目标方法(无异常情况)，顺序：@Around =》@Before =》pjp.proceed()执行切点方法 =》@AfterReturning =》@After</li><li>如果有调用<code>pjp.proceed()</code>方法时，开始执行切点对应的目标方法(有异常情况)，顺序：@Around =》@Before =》目标方法发生异常，不返回数据 =》@AfterThrowing拦截 =》@After</li></ul></li><li>2.如果有多个切面，使用@Order(Integer)注解多个切面,Integer越小，优先级越高。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Spring两大特性&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;IOC(控制反转)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;IOC：通俗点来讲，就是把对象的创建交给Spring容器来管理，不用我们手动new&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;AOP(面</summary>
      
    
    
    
    <category term="spring" scheme="http://14uy2u.coding-pages.com/categories/spring/"/>
    
    
    <category term="Aop" scheme="http://14uy2u.coding-pages.com/tags/Aop/"/>
    
  </entry>
  
  <entry>
    <title>小撸redis</title>
    <link href="http://14uy2u.coding-pages.com/2021/02/21/DataBase/%E6%92%B8%E4%BA%86%E5%A5%BD%E4%B9%85%E7%9A%84redis/"/>
    <id>http://14uy2u.coding-pages.com/2021/02/21/DataBase/%E6%92%B8%E4%BA%86%E5%A5%BD%E4%B9%85%E7%9A%84redis/</id>
    <published>2021-02-21T08:00:15.000Z</published>
    <updated>2021-06-02T08:47:29.494Z</updated>
    
    <content type="html"><![CDATA[<h1>redis还是要会的</h1><h2 id="redis是什么"><a class="header-anchor" href="#redis是什么">¶</a>redis是什么</h2><ul><li>redis是一个高性能的非关系型数据库，相对于普通的关系型数据库，redis的数据储存在缓存中，<br>读(110000次/s)写(81000次/s )数据非常快，Redis也支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li></ul><h2 id="redis数据类型了解一下"><a class="header-anchor" href="#redis数据类型了解一下">¶</a>redis数据类型了解一下</h2><ul><li>String: 字符串</li><li>Hash: 散列</li><li>List: 列表</li><li>Set: 集合</li><li>Sorted Set: 有序集合</li></ul><h2 id="redis的安装和简单使用-windows环境下"><a class="header-anchor" href="#redis的安装和简单使用-windows环境下">¶</a>redis的安装和简单使用(windows环境下)</h2><h3 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h3><ol><li>下载地址：<a href="https://github.com/tporadowski/redis/releases%E3%80%82">https://github.com/tporadowski/redis/releases。</a></li><li>下载 Redis-x64-xxx.zip压缩包并解压到D:\redis</li></ol><h3 id="windows启动（两种方式）"><a class="header-anchor" href="#windows启动（两种方式）">¶</a>windows启动（两种方式）</h3><ul><li>启动方法有cmd命令启动和exe文件启动。其实他们都一样，命令只是暗地里操作exe文件启动而已。</li><li>启动成功标志，出现6379</li></ul><h4 id="方式一"><a class="header-anchor" href="#方式一">¶</a>方式一</h4><ul><li>因没有配置redis的环境变量，所以使用cmd命令启动时要注意切换到redis的安装目录(解压目录)D:\redis,</li><li>输入redis-server.exe redis.windows.conf回车，会生成一个窗口，注意不要关闭这个服务端窗口。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/moshengxin/Blog-Picture@main/test0423/redis-server.exe.3etu5brf2sa0.jpg" alt="yqOlvV.png"></li><li>然后再重新打开一个cmd窗口，输入redis-cli.exe -h 127.0.0.1 -p 6379，用于打开redis客户端，可查看redis相关信息和命令练习<br><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/02/23/yqOsbD.png" alt="yqOsbD.png"></li></ul><h4 id="方式二"><a class="header-anchor" href="#方式二">¶</a>方式二</h4><ul><li>exe文件启动，按照下图顺序启动服务端和客户端<br><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/02/23/yqLSS0.png" alt="yqLSS0.png"></li></ul><h3 id="linux启动"><a class="header-anchor" href="#linux启动">¶</a>linux启动</h3><ul><li>cd到redis安装的<code>bin</code>目录中，启动<code>redis-server</code>服务，启动完成了就运行<code>./redis-cli</code>打开客户端，然后就可以增删改了。</li><li>如果要远程连接linux下的redis，首先要确保redis-server服务要启动成功，并且6379端口要开放。然后在cmd中通过命令<code>redis-cli -h 10.106.252.131 -p 6379</code>连接，如果提示<code>(error) NOAUTH Authentication required.</code>错误，则使用命令<code>auth redis密码</code>来授权即可。</li></ul><h2 id="redis常用命令学习总结"><a class="header-anchor" href="#redis常用命令学习总结">¶</a>redis常用命令学习总结</h2><ul><li>redis共有16个库，顺序从下标0开始。默认是第一个库，如要切换库，则要使用命令select index    例如：select 1代表切换到第二个库。</li><li>查看库中所有的键：    keys *</li><li>命令太多要清屏：   clear</li></ul><h3 id="老老实实做一个redis练习生"><a class="header-anchor" href="#老老实实做一个redis练习生">¶</a>老老实实做一个redis练习生</h3><p>会唱、跳、rap、篮球还不够，还要会redis基础命令，下面是每个类型相关。</p><h4 id="String相关"><a class="header-anchor" href="#String相关">¶</a>String相关</h4><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/02/23/yqv0vq.png" alt="yqv0vq.png"><br><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/02/23/yqvrrV.png" alt="yqvrrV.png"></p><h4 id="Hash相关"><a class="header-anchor" href="#Hash相关">¶</a>Hash相关</h4><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/02/23/yqvhx1.png" alt="yqvhx1.png"></p><h4 id="List相关"><a class="header-anchor" href="#List相关">¶</a>List相关</h4><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/02/23/yqvbIe.png" alt="yqvbIe.png"></p><h4 id="Set相关"><a class="header-anchor" href="#Set相关">¶</a>Set相关</h4><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/02/23/yqvXRA.png" alt="yqvXRA.png"></p><h4 id="Sorted-Set相关"><a class="header-anchor" href="#Sorted-Set相关">¶</a>Sorted Set相关</h4><p>偷一下懒，移步去看<a href="https://www.runoob.com/redis/redis-sorted-sets.html">菜鸟教程对应版块</a></p><h2 id="redis的几个特性理解"><a class="header-anchor" href="#redis的几个特性理解">¶</a>redis的几个特性理解</h2><ol><li>缓存穿透 、<ul><li>是指当Redis缓存中的key不存在value值时，就会请求到后台去查询数据库，如果并发量很高，就会造成数据库宕机</li><li>解决办法：法1：查到空数据也进行缓存，但要求设置很短的过期时间，一般为几分钟。法二：布隆过滤器</li></ul></li><li>缓存击穿<ul><li>是指Redis缓存中的key存在value值，但是过期了，该请求还是会去后台请求查询数据库，如果并发量很高同时查询同一条数据，也会造成数据库宕机。</li><li>解决办法：法一：直接设为永不过期就。法二：加互斥锁</li></ul></li><li>缓存雪崩 、<ul><li>是指多条或者无数条数据过期了，造成系统崩溃（例如：热点商品秒杀）</li><li>解决办法：<ul><li>法一：直接设为永不过期就。</li><li>法二：随机过期(过期一部分，目的防止同一时间大量数据过期现象发生。)</li></ul></li></ul></li></ol><h2 id="Redis持久化的rdb方式和aof方式备份的区别"><a class="header-anchor" href="#Redis持久化的rdb方式和aof方式备份的区别">¶</a>Redis持久化的rdb方式和aof方式备份的区别</h2><ul><li>RDB每隔一段时间进行备份，AOF每时每刻在写操作时进行备份，所以AOF备份出来的文件比RDB的要大，数据完整性也比RDB的要好。不过官方建议同时开启这两种持久化</li><li>Redis 默认的持久化方式是 RDB ，并且默认是打开的</li><li>在配置文件中满足这些条件就会触发RDB备份操作</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><ul><li>如果要开启AOF备份，则要在配置文件中把 appendonly 改为 yes开启</li><li>AOF备份有三种方式，在配置文件中选择其中一种即可</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># appendfsync always       &#x2F;&#x2F;实时，每个操作都会备份(IO开销大)    </span><br><span class="line">appendfsync everysec      &#x2F;&#x2F;每秒，redis宕机会丢失一秒的数据(建议使用)</span><br><span class="line"># appendfsync no          </span><br></pre></td></tr></table></figure><h2 id="Redis数据恢复"><a class="header-anchor" href="#Redis数据恢复">¶</a>Redis数据恢复</h2><ul><li>如果有AOF文件,优先恢复AOF，没有则恢复RDB文件</li></ul><h2 id="Redis集群"><a class="header-anchor" href="#Redis集群">¶</a>Redis集群</h2><h3 id="集群定义"><a class="header-anchor" href="#集群定义">¶</a>集群定义</h3><ul><li>所谓的集群，就是通过添加多个相同的服务器，防止某台服务器发生事故，导致系统不能正常运行，从而让服务器达到一个稳定、高效的状态。<ul><li>主从复制、<ul><li>主库可读、可写。从库只读不写，所以可以把查询统统交给从库，增删改就交给主库。</li><li>ps：Master主库有且仅有一个，建议从库最少设置两个</li></ul></li><li>哨兵模式、<ul><li>因为主从复制集群有一个致命的缺点，那就是主库发生故障，就不能进行增删改了，所以就产生了哨兵模式，<br>* 所谓的哨兵模式，就是当主库发生故障后，哨兵会在所有的从库中，自动选举一个新的库作为主库来进行增删改操作。</li></ul></li></ul></li></ul><h3 id="集群搭建"><a class="header-anchor" href="#集群搭建">¶</a>集群搭建</h3><ul><li><a href="https://blog.csdn.net/qq_42815754/article/details/82912130">手把手教程</a></li></ul><h3 id="Redis事务"><a class="header-anchor" href="#Redis事务">¶</a>Redis事务</h3><ul><li>相关命令：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">multi               <span class="comment">//开启事务</span></span><br><span class="line">set .......        <span class="comment">//数据库操作入队</span></span><br><span class="line">exec/discard      <span class="comment">//执行或取消队列</span></span><br></pre></td></tr></table></figure><ul><li>PS:Redis不支持事务回滚，队列中的某一个操作失败，其它的剩余操作照样执行，因为Redis认为这种错误应该发生在开发环境中，不应该出现在正式环境中，Redis并不帮程序员解决他造成的错误</li></ul><h2 id="linux中-ubuntu-设置redis可远程访问"><a class="header-anchor" href="#linux中-ubuntu-设置redis可远程访问">¶</a>linux中(ubuntu)设置redis可远程访问</h2><ul><li>1️⃣ 找到redis的配置文件redis.conf,该文件位于/etc/redis文件夹下</li></ul><blockquote><p>cd /etc/redis</p></blockquote><ul><li>2️⃣ vi编辑redis.conf,把<code>bind 127.0.0.1 ::1</code>注释掉,并关闭保护模式，即把<code>protected-mode no</code>改为<code>yes</code></li><li>3️⃣ 防火墙开放redis的6379端口,</li></ul><blockquote><p>firewall-cmd --zone=public --add-port=6379/tcp --permanent</p></blockquote><ul><li>4️⃣ 重启防火墙配置</li></ul><blockquote><p>firewall-cmd --reload</p></blockquote><ul><li>5️⃣ 重启redis服务就可以远程访问了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;redis还是要会的&lt;/h1&gt;
&lt;h2 id=&quot;redis是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis是什么&quot;&gt;¶&lt;/a&gt;redis是什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;redis是一个高性能的非关系型数据库，相对于普通的关系型数据库</summary>
      
    
    
    
    <category term="数据库" scheme="http://14uy2u.coding-pages.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="redis" scheme="http://14uy2u.coding-pages.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java开发规范总结</title>
    <link href="http://14uy2u.coding-pages.com/2021/02/06/java/java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/"/>
    <id>http://14uy2u.coding-pages.com/2021/02/06/java/java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-06T09:57:15.000Z</published>
    <updated>2021-02-23T09:16:24.756Z</updated>
    
    <content type="html"><![CDATA[<h1>Java开发规范总结</h1><h2 id="一些命名和定义规范"><a class="header-anchor" href="#一些命名和定义规范">¶</a>一些命名和定义规范</h2><ul><li>类名使用 UpperCamelCase 风格(单词首字母大写)，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO</li><li>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格(第一个单词小写，后面的都大写)</li><li>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</li><li>抽象类User命名AbstractUser，异常类UserException，测试类UserTest</li><li>实体类Boolean类型的属性命名都不要加 is，例如Boolean isDeleted不推荐</li><li>包名统一使用小写，com.公司名.项目名.模块名…或者cn.公司名.项目名.模块名…</li><li>Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。正例：Long a=10000L</li></ul><h2 id="代码格式相关"><a class="header-anchor" href="#代码格式相关">¶</a>代码格式相关</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 缩进 4 个空格 </span></span><br><span class="line">    String say = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 运算符的左右必须有一个空格 </span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 </span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123; </span><br><span class="line">       System.out.println(say); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左大括号前加空格且不换行；左大括号后换行 </span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123; </span><br><span class="line">       System.out.println(<span class="string">&quot;world&quot;</span>); </span><br><span class="line">        <span class="comment">// 右大括号前换行，右大括号后有 else，不用换行 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">       System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">       <span class="comment">// 在右大括号后直接结束，则必须换行 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正例： </span></span><br><span class="line">  <span class="string">&quot;test&quot;</span>.equals(object); </span><br><span class="line"><span class="comment">// 反例： </span></span><br><span class="line">  object.equals(<span class="string">&quot;test&quot;</span>); </span><br><span class="line"><span class="comment">// 说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类）</span></span><br></pre></td></tr></table></figure><ul><li>单行字符数限制不超过 120 个，超出需要换行，第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进</li><li>方法参数在定义和传入时，多个参数逗号后边必须加空格。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正例：下例中实参的&quot;a&quot;,后边必须要有一个空格。 </span></span><br><span class="line">    method(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>类的静态变量或静态方法直接使用类名.来访问</li><li>如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。</li><li>工具类不允许有 public 或 default <font color="#FF0000">构造方法</font></li><li>工具类的方法常多用static修饰，使用的时候直接类名.方法（）</li><li>工具类常量定义和普通类常量定义一样，都用public static final 修饰</li><li>在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程 序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且 放在最后，即使它什么代码也没有</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，<font color="#ff0000">避免使用 单行的形式</font>：if (condition) statements;</li><li>表达异常的分支时，少用 if-else 方式，这种方式可以改写成：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 接着写 else 的业务逻辑代码;</span></span><br></pre></td></tr></table></figure><p>如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维 护困难，请勿超过 3 层。 正例：逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">today</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBusy()) &#123;</span><br><span class="line">        System.out.println(“change time.”);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFree()) &#123;</span><br><span class="line">        System.out.println(“go to travel.”);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(“stay at home to learn Alibaba Java Coding Guideline.”);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果if的判断条件表达式很长，应该将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> existed = (file.open(fileName, <span class="string">&quot;w&quot;</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...);</span><br><span class="line"><span class="keyword">if</span> (existed) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不建议在循环中定义对象、变量、 获取数据库连接，以及进行不必要的 try-catch 操作，条件允许下尽可能在循环体外进行，不然会影响代码性能</li></ul><h2 id="注释相关"><a class="header-anchor" href="#注释相关">¶</a>注释相关</h2><ul><li>类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*<em>内容</em>/格式，不得使用 //xxx 方式。因为Javadoc格式鼠标移动会提示。//xxx格式却不能</li><li>所有的枚举类型字段必须要有注释，说明每个数据项的用途。</li><li>项目中注释掉的代码。说明：代码被注释掉有两种可能性：<br>1）后续会恢复此段代码逻辑。<br>2）如果永久不用。则删除（不用怕，代码仓库保存了历史代码）。</li></ul><h2 id="其它"><a class="header-anchor" href="#其它">¶</a>其它</h2><ul><li>正则表达式不要在方法体内定义</li></ul><h1>MySQL相关</h1><ul><li>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint。<br>例子：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</li><li>表名、字段名必须使用小写字母或数字。例子：getter_admin，task_config，level3_name</li><li>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名</li><li>小数类型为 decimal，禁止使用 float 和 double（精度会丢失）</li><li>char 类型的存放固定长度的数据  如：身份证号(18） 手机号电话号(11)  性别(1)等等，如果存储的数据的大小比定义时的小，会自动补全。存储固定的长度</li><li>varchar类型长度可变。</li><li>in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控 制在 1000 个之内。</li><li>TRUNCATE TABLE 比 DELETE 速度快，TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</li><li>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</li></ul><hr><p>摘录自某阿里巴巴开发手册，哪个版本的忘记了🐷。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java开发规范总结&lt;/h1&gt;
&lt;h2 id=&quot;一些命名和定义规范&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#一些命名和定义规范&quot;&gt;¶&lt;/a&gt;一些命名和定义规范&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类名使用 UpperCamelCase 风格(单词首字母大</summary>
      
    
    
    
    <category term="规范" scheme="http://14uy2u.coding-pages.com/categories/%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="java" scheme="http://14uy2u.coding-pages.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>List去重</title>
    <link href="http://14uy2u.coding-pages.com/2021/01/17/java/list%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://14uy2u.coding-pages.com/2021/01/17/java/list%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/</id>
    <published>2021-01-17T09:57:15.000Z</published>
    <updated>2021-03-18T02:08:36.598Z</updated>
    
    <content type="html"><![CDATA[<h1>List去重总结</h1><h2 id="List和Set区别"><a class="header-anchor" href="#List和Set区别">¶</a>List和Set区别</h2><p>Java中的集合分三大类，分别是Set（集），List（列表）以及Map（映射）</p><ul><li><p>1、List和Set都是接口继承于Collection接口。</p></li><li><p>2、List有序可重复的。而Set无序不可重复的</p></li><li><p>3、List接口的三个实现类：LinkedList，ArrayList，Vector ，Set接口的两个实现类：HashSet，LinkedHashSet</p></li><li><p>4、List适合经常追加数据，插入，删除数据。但随机取数效率比较低。</p></li><li><p>5、Set适合经常地随机储存，插入，删除。但是在遍历时效率比较低。</p></li></ul><h2 id="去重方法"><a class="header-anchor" href="#去重方法">¶</a>去重方法</h2><ul><li>1、运用Set无序不重复特性</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>));</span><br><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;(list1.size());  </span><br><span class="line">List&lt;Integer&gt; newlist= <span class="keyword">new</span> ArrayList&lt;Integer&gt;(list1.size());  </span><br><span class="line"><span class="keyword">for</span> (Integer it : list1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (set.add(it)) &#123;   <span class="comment">//运用Set无序不可重复特点来判断</span></span><br><span class="line">        newlist.add(it);  <span class="comment">//把不重复的数据添加到新的newlist</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">list1.clear();   <span class="comment">//循环后把原list1清空</span></span><br><span class="line">list1.addAll(newlist);  <span class="comment">//再把新的newlist全部加到list1中去，得到去重后的list1</span></span><br><span class="line">System.out.println(list1);  <span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><ul><li>2、list转set自动去重</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list2转set的时候去重,set再转newlist2</span></span><br><span class="line">LinkedList&lt;Integer&gt; list2= <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">LinkedHashSet&lt;Integer&gt; lhset= <span class="keyword">new</span> LinkedHashSet&lt;&gt;(list2);</span><br><span class="line"></span><br><span class="line">LinkedList&lt;Integer&gt; newlist2= <span class="keyword">new</span> LinkedList&lt;&gt;(lhset);</span><br><span class="line"></span><br><span class="line">System.out.println(newlist2);<span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><ul><li>3、遍历list3，用contains判断有重复的就不存放到newlist3中去。循环结束后把list3清空，再把newlist3全部放进去，得到去重后的list3</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">LinkedList&lt;Integer&gt; list3= <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>));</span><br><span class="line">LinkedList&lt;Integer&gt; newlist3=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list3.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!newlist3.contains(list3.get(i)))&#123;</span><br><span class="line">        newlist3.add(list3.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">list3.clear();</span><br><span class="line">list3.addAll(newlist3);</span><br><span class="line">System.out.println(list3); <span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><ul><li>4、用Stream流的distinct方法去重</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> LinkedList&lt;Integer&gt; list4= <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>));</span><br><span class="line"> Stream&lt;Integer&gt; liststream= list4.stream().distinct();</span><br><span class="line"></span><br><span class="line"><span class="comment">// distinct.forEach(res-&gt; System.out.println(res));  //输出每一项    </span></span><br><span class="line"><span class="comment">//重复后的liststream转成newlist4</span></span><br><span class="line">List&lt;Integer&gt; newlist4= liststream.collect(Collectors.toList());  </span><br><span class="line"> System.out.println(newlist4);<span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><ul><li>5、如果List中存放的是Entity类对象，要根据某个字段去重，可考虑TreeSet去重</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">    ......       <span class="comment">//省略get、set、构造等一系列方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">List&lt;Student&gt; students = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="number">20</span>, <span class="number">91</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="number">20</span>, <span class="number">90</span>), </span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;小黑&quot;</span>, <span class="number">19</span>, <span class="number">60</span>), </span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;小白&quot;</span>, <span class="number">22</span>, <span class="number">89</span>)</span><br><span class="line">        );</span><br><span class="line"><span class="comment">//定义一个Student类的TreeSet,根据Name字段比较去重的比较器</span></span><br><span class="line">TreeSet&lt;Student&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;(Comparator.comparing(Student::getName)); </span><br><span class="line"><span class="comment">//Students实体类对象students添加到TreeSet中去进行比较</span></span><br><span class="line">treeSet.addAll(students);</span><br><span class="line"><span class="comment">//TreeSet再转换成List</span></span><br><span class="line">List&lt;Student&gt; resList= treeSet.stream().collect(Collectors.toList());</span><br><span class="line">System.out.println(resList);</span><br></pre></td></tr></table></figure><h3 id="就着Stream-顺便记录一下排序"><a class="header-anchor" href="#就着Stream-顺便记录一下排序">¶</a>就着Stream,顺便记录一下排序</h3><ul><li>java8新特性了解一下</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">    ......       <span class="comment">//省略get、set、构造等一系列方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">List&lt;Student&gt; students = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="number">20</span>, <span class="number">91</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="number">20</span>, <span class="number">90</span>), </span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;小黑&quot;</span>, <span class="number">19</span>, <span class="number">60</span>), </span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;小白&quot;</span>, <span class="number">22</span>, <span class="number">89</span>)</span><br><span class="line">        );</span><br><span class="line"> <span class="comment">//students对象转流后进行sorted排序，根据Age字段排序，limit取前两条。</span></span><br><span class="line">Stream&lt;Student&gt; sortedStream = students.stream().sorted((item2, item1) -&gt; item1.getAge() - item2.getAge()).limit(<span class="number">2</span>);</span><br><span class="line">List&lt;Student&gt; newList= sortedStream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;List去重总结&lt;/h1&gt;
&lt;h2 id=&quot;List和Set区别&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#List和Set区别&quot;&gt;¶&lt;/a&gt;List和Set区别&lt;/h2&gt;
&lt;p&gt;Java中的集合分三大类，分别是Set（集），List（列表）以及M</summary>
      
    
    
    
    <category term="List 集合" scheme="http://14uy2u.coding-pages.com/categories/List-%E9%9B%86%E5%90%88/"/>
    
    
    <category term="java" scheme="http://14uy2u.coding-pages.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMq学习</title>
    <link href="http://14uy2u.coding-pages.com/2021/01/07/ActiveMq/"/>
    <id>http://14uy2u.coding-pages.com/2021/01/07/ActiveMq/</id>
    <published>2021-01-07T08:19:18.000Z</published>
    <updated>2021-01-07T08:51:21.351Z</updated>
    
    <content type="html"><![CDATA[<h1>ActiveMq相关认识</h1><p>ActiveMq是一个消息队列中间件，类似的还有RabbitMQ、Kafka等。</p><h2 id="ActiveMq的优点或者作用"><a class="header-anchor" href="#ActiveMq的优点或者作用">¶</a>ActiveMq的优点或者作用</h2><h3 id="解耦"><a class="header-anchor" href="#解耦">¶</a>解耦</h3><ul><li>在大型网站中最常见使用消息中间件，能降低应用的耦合度。<br>比如：在订单系统和库存系统中引入消息中间件，如果用户下单成功后，库存系统刚好发生宕机故障，也不会影响数据，因为下单成功后，已经把减库存的操作持久化告诉ActiveMq，ActiveMq会在库存系统恢复正常的时候提醒写入数据到库存系统。</li></ul><h3 id="流量消峰-解决高并发场景"><a class="header-anchor" href="#流量消峰-解决高并发场景">¶</a>流量消峰(解决高并发场景)</h3><ul><li>没有中间件的之前，在整点秒杀和抢购活动中，大量的同一请求会同时对数据库进行CRUD操作。因为ActiveMq是先进先出，所以当有大量同求时，先经过ActiveMq把请求集中起来统一管理，采用定义好的规则把请求分批处理。这样就能直到保护数据库的作用。<br>上面所说规则可理解为，500个商品，100000个抢购请求，那么ActiveMq就会把所有的请求先集中处理，前500个先进先出，500之后的就抢购失败，不经过数据库处理，直接抛弃用户请求或跳转到抢购失败页面提示用户抢购失败。<br>ps:解耦这个特定业务环境下是使用<strong>发布-订阅模式</strong>的</li></ul><h3 id="异步处理"><a class="header-anchor" href="#异步处理">¶</a>异步处理</h3><ul><li>将不是很重要的业务逻辑进行异步处理，比如注册功能，传统的注册功能要在完成发送注册邮件和注册短信后才响应给前端，这样显得有点慢，因为邮件和短信提示不算是很重要，可以在响应给用户后慢一点点发邮件和短信提示，所以我们可以把这两个部分都交给ActiveMq来异步处理。<br>具体可以看这篇博客<a href="https://www.cnblogs.com/cxyyh/p/10700437.html">戳这里</a>有图文，更易理解</li></ul><h2 id="ActiveMq的两种消息模型"><a class="header-anchor" href="#ActiveMq的两种消息模型">¶</a>ActiveMq的两种消息模型</h2><h3 id="ptp-点到点模型"><a class="header-anchor" href="#ptp-点到点模型">¶</a>ptp(点到点模型)</h3><ul><li>生产者和消费者一对一关系，消息保证送达，离线消费者可以在下次上线后收到之前积压的消息。</li></ul><h3 id="p-s-发布-订阅模型"><a class="header-anchor" href="#p-s-发布-订阅模型">¶</a>p/s(发布/订阅模型)</h3><ul><li>生产者和消费者一对多关系，一个消息生产者可以被多个消费者订阅消费。类似关注微信公众号一样，在你关注公众号前，公众号发布的文章，你是不能接收到推送的。只有你订阅后，公众号推送的文章你才能收到提醒。</li></ul><h4 id="p-s普通订阅"><a class="header-anchor" href="#p-s普通订阅">¶</a>p/s普通订阅</h4><ul><li>当没有持久订阅者和在线的普通订阅者，消息不会保存，普通订阅者上线后也收不到该消息。</li></ul><h4 id="p-s持久订阅"><a class="header-anchor" href="#p-s持久订阅">¶</a>p/s持久订阅</h4><ul><li>如果有离线的持久订阅者，ActiveMq会为该持久订阅者保存消息，当该持久订阅者上线后，会收到消息。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;ActiveMq相关认识&lt;/h1&gt;
&lt;p&gt;ActiveMq是一个消息队列中间件，类似的还有RabbitMQ、Kafka等。&lt;/p&gt;
&lt;h2 id=&quot;ActiveMq的优点或者作用&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#ActiveMq的优点或者</summary>
      
    
    
    
    <category term="消息中间件" scheme="http://14uy2u.coding-pages.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="高并发" scheme="http://14uy2u.coding-pages.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中Array的一些常用方法和操作</title>
    <link href="http://14uy2u.coding-pages.com/2020/12/01/%E5%89%8D%E7%AB%AF/JavaScript%E4%B8%ADArray%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%93%8D%E4%BD%9C/"/>
    <id>http://14uy2u.coding-pages.com/2020/12/01/%E5%89%8D%E7%AB%AF/JavaScript%E4%B8%ADArray%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%93%8D%E4%BD%9C/</id>
    <published>2020-12-01T09:35:18.000Z</published>
    <updated>2020-12-02T04:27:07.243Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1>JavaScript中Array的一些常用方法和操作</h1><p>JavaScript的 Array 对象是用于构造数组的全局对象，数组是类似于列表的高阶对象</p><h2 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h2><h3 id="数组创建"><a class="header-anchor" href="#数组创建">¶</a>数组创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组创建</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>];</span><br></pre></td></tr></table></figure><h3 id="数组长度"><a class="header-anchor" href="#数组长度">¶</a>数组长度</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组长度</span></span><br><span class="line"><span class="keyword">var</span> length=array.length();   <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="数组取值"><a class="header-anchor" href="#数组取值">¶</a>数组取值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、通过数组下标取值</span></span><br><span class="line"><span class="keyword">var</span> first = array[<span class="number">0</span>];   <span class="comment">//Apple</span></span><br><span class="line"><span class="comment">//2、for循环也可以取到想要的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> array)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;下标&quot;</span>+index)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;值&quot;</span>+array[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加数据"><a class="header-anchor" href="#添加数据">¶</a>添加数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向数组中添加数据(可在for循环中连续添加数据)</span></span><br><span class="line">array.push(obj)  <span class="comment">//obj为插入对象或者数据</span></span><br></pre></td></tr></table></figure><h3 id="判断数据在数组中对下标"><a class="header-anchor" href="#判断数据在数组中对下标">¶</a>判断数据在数组中对下标</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//某个数据在数组中对下标</span></span><br><span class="line">array.indexOf(<span class="string">&#x27;Apple&#x27;</span>);  <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h3 id="替换数组对应下标的数据"><a class="header-anchor" href="#替换数组对应下标的数据">¶</a>替换数组对应下标的数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换数组对应下标的元素，index为你要替换的下标位置，replaceData为替换数据。</span></span><br><span class="line">array.splice(index,<span class="number">1</span>,replaceData)</span><br></pre></td></tr></table></figure><h3 id="数组连接或者合并"><a class="header-anchor" href="#数组连接或者合并">¶</a>数组连接或者合并</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两个或多个数组(可为空数组)。此方法不会更改现有数组，而是返回一个新数组。</span></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];   <span class="comment">//可为空数组</span></span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];<span class="comment">//也可为空数组</span></span><br><span class="line"><span class="keyword">const</span> array3 = array1.concat(array2);  <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="查找满足条件的第一个值"><a class="header-anchor" href="#查找满足条件的第一个值">¶</a>查找满足条件的第一个值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回数组中满足条件的第一个元素的值。否则返回 undefined。</span></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"><span class="keyword">const</span> found = array1.find(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">10</span>);  <span class="comment">//从左到右，大于10的第一个数是12。</span></span><br><span class="line"><span class="built_in">console</span>.log(found);  <span class="comment">//所以输出12</span></span><br></pre></td></tr></table></figure><h3 id="判断数组是否包含某个值"><a class="header-anchor" href="#判断数组是否包含某个值">¶</a>判断数组是否包含某个值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断数组是否包含某个值</span></span><br><span class="line"><span class="keyword">const</span> pets = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;bat&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">&#x27;cat&#x27;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="数组转字符串，元素拼接成字符串"><a class="header-anchor" href="#数组转字符串，元素拼接成字符串">¶</a>数组转字符串，元素拼接成字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组转字符串，元素拼接成字符串</span></span><br><span class="line"><span class="keyword">const</span> elements = [<span class="string">&#x27;Fire&#x27;</span>, <span class="string">&#x27;Air&#x27;</span>, <span class="string">&#x27;Water&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(elements.join());  <span class="comment">//&quot;Fire,Air,Water&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(elements.join(<span class="string">&#x27;&#x27;</span>)); <span class="comment">//&quot;FireAirWater&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(elements.join(<span class="string">&#x27;-&#x27;</span>)); <span class="comment">//&quot;Fire-Air-Water&quot;</span></span><br></pre></td></tr></table></figure><h3 id="数组倒置与排序"><a class="header-anchor" href="#数组倒置与排序">¶</a>数组倒置与排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组倒置</span></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array1.reverse()) <span class="comment">//[&quot;3&quot;, &quot;2&quot;, &quot;1&quot;]</span></span><br><span class="line"><span class="comment">//数组排序方法1</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(numbers); <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">//数组排序方法2</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]; </span><br><span class="line">numbers.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); </span><br><span class="line"><span class="built_in">console</span>.log(numbers);  <span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="清空数组"><a class="header-anchor" href="#清空数组">¶</a>清空数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line">array1= [];</span><br><span class="line"><span class="comment">//方法2 </span></span><br><span class="line">array2.splice(<span class="number">0</span>,array2.length);  </span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line">array3.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h1&gt;JavaScript中Array的一些常用方法和操作&lt;/h1&gt;
&lt;p&gt;JavaScript的 Array 对象是用于构造数组的全局对象，数组是类似于列表的高阶对象&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a class=&quot;head</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://14uy2u.coding-pages.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript Array" scheme="http://14uy2u.coding-pages.com/tags/JavaScript-Array/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot项目整合Swagger-UI接口文档</title>
    <link href="http://14uy2u.coding-pages.com/2020/11/01/%E6%95%B4%E5%90%88/SpringBoot%E6%95%B4%E5%90%88Swagger-UI%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
    <id>http://14uy2u.coding-pages.com/2020/11/01/%E6%95%B4%E5%90%88/SpringBoot%E6%95%B4%E5%90%88Swagger-UI%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</id>
    <published>2020-11-01T08:00:18.000Z</published>
    <updated>2020-11-01T08:13:37.029Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1>SpringBoot整合Swagger-UI接口文档</h1><h2 id="Swagger-UI好处"><a class="header-anchor" href="#Swagger-UI好处">¶</a>Swagger-UI好处</h2><p>Swagger-UI   一个好看又好用的项目接口文档，可以动态地根据注解生成在线API文档。==也就是说和你代码的Controller层的接口方法对应，支持在线接口测试，不依赖第三方工具==</p><h2 id="Swagger-UI常用注解介绍"><a class="header-anchor" href="#Swagger-UI常用注解介绍">¶</a>Swagger-UI常用注解介绍</h2><p>==@Api==：用于修饰Controller类，生成Controller相关文档信息<br>==@ApiOperation==：用于修饰Controller类中的方法，生成接口方法相关文档信息<br>==@ApiParam==：用于修饰接口中的参数，生成接口参数相关文档信息<br>==@ApiModelProperty==：用于修饰实体类的属性，当实体类是请求参数或返回结果时，直接生成相关文档信息</p><h2 id="整合步骤"><a class="header-anchor" href="#整合步骤">¶</a>整合步骤</h2><h3 id="1、maven中添加依赖"><a class="header-anchor" href="#1、maven中添加依赖">¶</a>1、maven中添加依赖</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--Swagger-UI API文档生产工具--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2、项目中添加Swagger-UI配置类"><a class="header-anchor" href="#2、项目中添加Swagger-UI配置类">¶</a>2、项目中添加Swagger-UI配置类</h3><p>这里参考github上mall项目的配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swagger2API文档的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//为当前包下controller生成API文档</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.macro.mall.tiny.controller&quot;</span>))</span><br><span class="line">                <span class="comment">//为有@Api注解的Controller生成API文档</span></span><br><span class="line">                .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span><br><span class="line">                <span class="comment">//为有@ApiOperation注解的方法生成API文档</span></span><br><span class="line">               .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;SwaggerUI文档&quot;</span>)   </span><br><span class="line">                .description(<span class="string">&quot;某某某商城项目/系统后台所有接口文档&quot;</span>)</span><br><span class="line">                .contact(<span class="string">&quot;macro&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;版本号1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、配合注解使用"><a class="header-anchor" href="#3、配合注解使用">¶</a>3、配合注解使用</h3><p>在你要生成接口文档的Controller层的Class类上面添加@Api(tags = “PmsBrandController”, description = “商品品牌管理”)方法上面添加@ApiOperation(“获取所有品牌列表”)注解</p><p><a href="https://imgchr.com/i/Bwdkq0"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/11/01/Bwdkq0.png" alt="Bwdkq0.png"></a></p><h3 id="4、查看效果"><a class="header-anchor" href="#4、查看效果">¶</a>4、查看效果</h3><p>访问接口文档地址接口地址：<a href="http://localhost:8086/swagger-ui.html%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C%EF%BC%8C%E6%B3%A8%E6%84%8F%E6%8D%A2%E6%88%90%E8%87%AA%E5%B7%B1%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%88application.yml%E4%B8%AD%E6%9F%A5%E7%9C%8B%E6%88%96%E8%80%85%E8%AE%BE%E7%BD%AEspringboot%E9%A1%B9%E7%9B%AE%E7%AB%AF%E5%8F%A3%EF%BC%89%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF8086%E7%AB%AF%E5%8F%A3">http://localhost:8086/swagger-ui.html查看效果，注意换成自己项目的端口号（application.yml中查看或者设置springboot项目端口），我这里使用的是8086端口</a></p><p><a href="https://imgchr.com/i/Bwd2WQ"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/11/01/Bwd2WQ.png" alt="Bwd2WQ.png"></a><br>参考：<a href="https://github.com/macrozheng/mall">https://github.com/macrozheng/mall</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h1&gt;SpringBoot整合Swagger-UI接口文档&lt;/h1&gt;
&lt;h2 id=&quot;Swagger-UI好处&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Swagger-UI好处&quot;&gt;¶&lt;/a&gt;Swagger</summary>
      
    
    
    
    <category term="整合" scheme="http://14uy2u.coding-pages.com/categories/%E6%95%B4%E5%90%88/"/>
    
    
    <category term="SpringBoot" scheme="http://14uy2u.coding-pages.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令和操作总结</title>
    <link href="http://14uy2u.coding-pages.com/2020/10/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/linux/"/>
    <id>http://14uy2u.coding-pages.com/2020/10/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/linux/</id>
    <published>2020-10-02T07:29:46.000Z</published>
    <updated>2021-04-23T02:36:00.587Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux常用命令和操作总结</h1><h2 id="Linux是什么"><a class="header-anchor" href="#Linux是什么">¶</a>Linux是什么</h2><p>非官方套路，开始先来一大堆看不懂的介绍。</p><ul><li>Linux 是在 1991 由林纳斯·托瓦兹在赫尔辛基大学上学时创立的，主要受到 Minix 和 Unix 思想的启发，所以Linux继承了Unix。</li><li>Linux是开源的，目前我所了解到的Linux的发行版有Ubuntu和CentOS。当然还有其它的。<strong>本篇主要是在Ubuntu 20.04.1版本上操作Linux</strong>。</li><li>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。</li></ul><h2 id="相关环境准备"><a class="header-anchor" href="#相关环境准备">¶</a>相关环境准备</h2><ul><li>Ubuntu的运行要依赖于Vm虚拟机，关于Vm和Ubuntu的安装，可以戳这里<a href="https://blog.csdn.net/hao5119266/article/details/89198275">快点我</a>，跟着教程一步步来。相信我，你可以的。</li></ul><h2 id="Linux常用命令总结"><a class="header-anchor" href="#Linux常用命令总结">¶</a>Linux常用命令总结</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;进入文件夹</span><br><span class="line">cd dir          </span><br><span class="line">&#x2F;&#x2F;跳转到首次进入终端时的路径，相当于用户根目录吧。</span><br><span class="line">cd ~</span><br><span class="line">&#x2F;&#x2F;返回上一级，如果是..&#x2F;..则代表返回上两级</span><br><span class="line">cd ..</span><br><span class="line">&#x2F;&#x2F;返回进入此目录之前所在目录(注意和cd..区分开来)</span><br><span class="line">cd - </span><br><span class="line">&#x2F;&#x2F;查看当前目录下有什么内容</span><br><span class="line">ls</span><br><span class="line">&#x2F;&#x2F;罗列出当前文件或目录的详细信息，含有时间、读写权限、大小、时间等信息 </span><br><span class="line">ll</span><br><span class="line">&#x2F;&#x2F;查看当前所在的全路径</span><br><span class="line">pwd </span><br><span class="line">&#x2F;&#x2F;清除屏幕所有命令</span><br><span class="line">clear</span><br><span class="line">&#x2F;&#x2F;把file文件移动到dir目录，其中file也可以是一个目录</span><br><span class="line">mv file dir</span><br><span class="line">&#x2F;&#x2F;把file文件复制一份到dir目录</span><br><span class="line">cp -r fileurl dir        </span><br><span class="line">&#x2F;&#x2F;解压xxx.tar.gz到当前目录     </span><br><span class="line">tar zxvf xxx.tar.gz     </span><br><span class="line">&#x2F;&#x2F;把xxx.tar.gz解压到指定的dir文件夹      </span><br><span class="line">tar zxvf xxx.tar.gz -C dir   </span><br><span class="line">&#x2F;&#x2F;参数为文件或者文件夹的路径。使用sudo会要求用户输入密码。   </span><br><span class="line">sudo rm -r 参数      </span><br><span class="line">&#x2F;&#x2F;查看ubuntu版本号         </span><br><span class="line">cat &#x2F;etc&#x2F;issue             </span><br><span class="line">&#x2F;&#x2F;安装软件 </span><br><span class="line">sudo apt install [software]  </span><br><span class="line">&#x2F;&#x2F;卸载软件</span><br><span class="line">sudo apt remove [software]   </span><br><span class="line">&#x2F;&#x2F;创建test.txt文件</span><br><span class="line">touch test.txt</span><br></pre></td></tr></table></figure><ul><li>如果不想每次安装都用<code>sudo</code>，则要使用<code>su root</code>切换到root用户。ubuntu默认不开启root用户，如果要开启就要设置一个root密码，具体百度一下，这里不作介绍。</li></ul><h2 id="Linux终端里的颜色区分"><a class="header-anchor" href="#Linux终端里的颜色区分">¶</a>Linux终端里的颜色区分</h2><ol><li>蓝色------&gt;目录</li><li>绿色------&gt;可执行文件</li><li>红色------&gt;压缩文件</li><li>浅蓝色—&gt;链接文件</li><li>灰色------&gt;其他文件</li></ol><h2 id="vim编辑器日常使用"><a class="header-anchor" href="#vim编辑器日常使用">¶</a>vim编辑器日常使用</h2><ul><li>vim编辑器有3种模式，分别是<strong>命令模式、插入模式、底线命令模式</strong>。<br><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/08/sn2Iqs.png" alt></li><li>在进行编辑时，你要注意的是模式的切换，vi编辑<strong>默认进入命令模式(此时不能输入内容)</strong>，如果想在文件中插入内容，则要先按下&quot;i&quot;，然后才可以输入，输入完后，再按Esc退出插入模式。然后按“shift+;”输入:冒号，进入底线命令。再输入wq保存退出。</li><li>如果在编辑过程中==出现键盘方向键变成ABCD==的情况，解决方法如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;按顺序执行以下命令</span><br><span class="line">sudo apt-get remove vim-common</span><br><span class="line">sudo apt-get install aptitude</span><br><span class="line">sudo aptitude install vim</span><br></pre></td></tr></table></figure><h2 id="vim设置永久显示行号命令"><a class="header-anchor" href="#vim设置永久显示行号命令">¶</a>vim设置永久显示行号命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;按顺序执行以下命令</span><br><span class="line">vim ~&#x2F;.vimrc    &#x2F;&#x2F;打开配置文件</span><br><span class="line">:set nu         &#x2F;&#x2F;在编辑区中输入:set nu</span><br><span class="line">:wq             &#x2F;&#x2F;保存并退出</span><br></pre></td></tr></table></figure><ul><li>如果用:wq保存文件报“无法打开并写入文件”错误，请用下面的命令保存：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;忽略权限保存</span><br><span class="line">: w ! sudo tee %</span><br></pre></td></tr></table></figure><h2 id="一招教你区分mv命令"><a class="header-anchor" href="#一招教你区分mv命令">¶</a>一招教你区分<code>mv</code>命令</h2><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">mv source_file(文件) dest_file(文件)</td><td style="text-align:center">将源文件名 source_file 改为目标文件名 dest_file</td></tr><tr><td style="text-align:center">mv source_file(文件) dest_directory(目录)</td><td style="text-align:center">将文件 source_file 移动到目标目录 dest_directory 中</td></tr><tr><td style="text-align:center">mv source_directory(目录) dest_directory(目录)</td><td style="text-align:center">目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory</td></tr><tr><td style="text-align:center">mv source_directory(目录) dest_file(文件)</td><td style="text-align:center">出错</td></tr></tbody></table><h2 id="防火墙相关命令"><a class="header-anchor" href="#防火墙相关命令">¶</a>防火墙相关命令</h2><ul><li>查看防火墙状态(running已开启、dead已关闭)</li></ul><blockquote><p>systemctl status firewalld</p></blockquote><ul><li>关闭防火墙</li></ul><blockquote><p>service firewalld stop</p></blockquote><ul><li>开启防火墙(重启用restart)</li></ul><blockquote><p>service firewalld start</p></blockquote><ul><li>开放某个端口可以所有外网访问，例如开放8080端口</li></ul><blockquote><p>firewall-cmd --zone=public --add-port=8080/tcp --permanent</p></blockquote><ul><li>移除防火墙的某个端口(例如：8080)</li></ul><blockquote><p>firewall-cmd --zone=public --remove-port=8080/tcp</p></blockquote><ul><li>防火墙重新加载配置</li></ul><blockquote><p>firewall-cmd --reload</p></blockquote><ul><li>查看开放的端口列表</li></ul><blockquote><p>firewall-cmd --list-ports</p></blockquote><h2 id="Linux软件安装-Ubuntu下"><a class="header-anchor" href="#Linux软件安装-Ubuntu下">¶</a>Linux软件安装(Ubuntu下)</h2><ul><li>Linux 大小写敏感</li><li>如果发现使用&quot;sudo apt-get install xxxx&quot;命令报“在等待缓存锁：无法获得锁…由进程7358持有”错误的话，可以使用以下命令解决</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;依次运行</span><br><span class="line">sudo rm &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend</span><br><span class="line">sudo rm &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;lock</span><br><span class="line">sudo rm &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock</span><br></pre></td></tr></table></figure><h3 id="tomcat安装"><a class="header-anchor" href="#tomcat安装">¶</a>tomcat安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建tomcat命令</span><br><span class="line">mkdir tomcat   </span><br><span class="line">&#x2F;&#x2F;进入tomcat目录</span><br><span class="line">cd tomcat     </span><br><span class="line">&#x2F;&#x2F;下载tomcat8.5压缩包</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.bfsu.edu.cn&#x2F;apache&#x2F;tomcat&#x2F;tomcat-8&#x2F;v8.5.61&#x2F;bin&#x2F;apache-tomcat-8.5.61.tar.gz  </span><br><span class="line">&#x2F;&#x2F;解压到当前目录</span><br><span class="line">tar xzvf apache-tomcat-8.5.61.tar.gz   </span><br><span class="line">&#x2F;&#x2F;然后进入 apache-tomcat-8.5.61</span><br><span class="line">cd apache-tomcat-8.5.61&#x2F;   </span><br><span class="line">&#x2F;&#x2F;进入到bin目录       </span><br><span class="line">cd bin     </span><br><span class="line">&#x2F;&#x2F;启动tomcat，并自行在浏览器输入localhost:8080查看是否启动成功                       </span><br><span class="line">.&#x2F;startup.sh      </span><br><span class="line">&#x2F;&#x2F;停止tomcat                 </span><br><span class="line">.&#x2F;shutdown.sh            </span><br></pre></td></tr></table></figure><h3 id="mysql安装"><a class="header-anchor" href="#mysql安装">¶</a>mysql安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;以下是根据回忆写的。其中有可能会少了某一步，有待验证</span><br><span class="line">&#x2F;&#x2F;1、创建文件夹：</span><br><span class="line">mkdir mysql</span><br><span class="line">&#x2F;&#x2F;2、cd mysql后下载rpm文件：</span><br><span class="line">wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-11.noarch.rpm</span><br><span class="line">&#x2F;&#x2F;3、安装服务</span><br><span class="line">yum install -y mysql-community-server</span><br><span class="line">&#x2F;&#x2F;4、启动mysql：</span><br><span class="line">service mysqld start</span><br><span class="line">&#x2F;&#x2F;5、登录mysql:  </span><br><span class="line">sudo mysql -u root -p</span><br><span class="line">&#x2F;&#x2F;6、查看所有库：</span><br><span class="line">show databases;（ps:sql命令不要忘记结束;标记）</span><br><span class="line">&#x2F;&#x2F;7、选择使用某个库：</span><br><span class="line">use 库名</span><br><span class="line">&#x2F;&#x2F;8、查看库中所有表：</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure><h3 id="mysql安装成功后，设置外网访问"><a class="header-anchor" href="#mysql安装成功后，设置外网访问">¶</a>mysql安装成功后，设置外网访问</h3><ul><li>1.防火墙开放mysql的3306端口</li></ul><blockquote><p>firewall-cmd --zone=public --add-port=3306/tcp</p></blockquote><ul><li>2.防火墙重新加载配置</li></ul><blockquote><p>firewall-cmd reload</p></blockquote><ul><li>3.进入/etc/mysql/mysql.conf.d中的mysqld.cnf文件</li></ul><blockquote><p>cd /etc/mysql/mysql.conf.d</p></blockquote><ul><li>4.用vi编辑命令进入文件并注释掉bind-address  = 127.0.0.1，保存并退出</li></ul><blockquote><p>vi mysqld.cnf</p></blockquote><ul><li>5.重启mysql后，外网便可连接成功</li></ul><blockquote><p>systemctl resatrt mysql或者service mysql restart</p></blockquote><h3 id="nginx安装"><a class="header-anchor" href="#nginx安装">¶</a>nginx安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1、安装：</span><br><span class="line">sudo apt install nginx</span><br><span class="line">&#x2F;&#x2F;2、查看版本：</span><br><span class="line">nginx -V</span><br><span class="line">&#x2F;&#x2F;3、启动nginx：</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br><span class="line">&#x2F;&#x2F;4、浏览器访问：localhost:80显示欢迎页代表启动成功(nginx默认端口80)</span><br></pre></td></tr></table></figure><h3 id="top命令查看Linux进程相关"><a class="header-anchor" href="#top命令查看Linux进程相关">¶</a>top命令查看Linux进程相关</h3><blockquote><p>查看所有进程：top</p></blockquote><blockquote><p>退出top命令行：q</p></blockquote><blockquote><p>按Cpu占比排序(高–低)：shift + p</p></blockquote><blockquote><p>按内存占比排序(高–低)：shift + m</p></blockquote><blockquote><p>切换排序列：shift + &gt;或者shift + &lt;</p></blockquote><blockquote><p>top命令默认的排序列是“%CPU”。</p></blockquote><blockquote><p>高亮显示排序列：x</p></blockquote><blockquote><p>查看8080端口占用的PID进程：lsof -i:8080（主要看项目yml配置文件用的是哪个端口）</p></blockquote><blockquote><p>杀进程：kill -9 PID代号</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Linux常用命令和操作总结&lt;/h1&gt;
&lt;h2 id=&quot;Linux是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Linux是什么&quot;&gt;¶&lt;/a&gt;Linux是什么&lt;/h2&gt;
&lt;p&gt;非官方套路，开始先来一大堆看不懂的介绍。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://14uy2u.coding-pages.com/categories/Linux/"/>
    
    
    <category term="ubuntu" scheme="http://14uy2u.coding-pages.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ping测试两个IP网络之间的连通性</title>
    <link href="http://14uy2u.coding-pages.com/2020/09/27/%E7%BD%91%E7%BB%9C/Ping%E6%B5%8B%E8%AF%95%E4%B8%A4%E4%B8%AAIP%E7%BD%91%E7%BB%9C%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
    <id>http://14uy2u.coding-pages.com/2020/09/27/%E7%BD%91%E7%BB%9C/Ping%E6%B5%8B%E8%AF%95%E4%B8%A4%E4%B8%AAIP%E7%BD%91%E7%BB%9C%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7/</id>
    <published>2020-09-27T09:05:18.000Z</published>
    <updated>2020-09-27T13:38:46.028Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="使用ping或者telnet命令"><a class="header-anchor" href="#使用ping或者telnet命令">¶</a>使用ping或者telnet命令</h2><p>1、ping和telnet命令作用类似，都是来测试网络的连通性,一般用ping就可以了</p><p>2、ping命令写法/格式：ping+ip/domain(ip也可以是本机ip，domain为域名，<a href="http://xn--www-uc0ep96b.baidu.com">例如www.baidu.com</a>)</p><p>3、ping命令会发送四次数据包，看到“已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)”代表能连通</p><p>4、telnet命令写法/格式：telnet+ip/domain+port(把ip换成domain也可以，port为端口号)</p><p>5、telnet成功后。cmd窗口一片黑色，只显示一个跳动的点点，不会显示其它内容，说明端口能连通。如果显示’telnet’ 不是内部或外部命令，则需要去系统中开启telnet客户端(教程:<a href="https://blog.csdn.net/qq_35428201/article/details/81048134">https://blog.csdn.net/qq_35428201/article/details/81048134</a>)</p><p><em>好记性不如烂笔头，多记录多学习</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;使用ping或者telnet命令&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#使用ping或者telnet命令&quot;&gt;¶&lt;/a&gt;使用ping或者telnet命令&lt;/h2&gt;
&lt;p&gt;1、ping和tel</summary>
      
    
    
    
    <category term="网络" scheme="http://14uy2u.coding-pages.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://14uy2u.coding-pages.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
